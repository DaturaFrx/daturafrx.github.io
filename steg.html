<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Enhanced Stego Mnemonic — Compact + Micro Modes</title>
<style>
body { font-family: Inter, Arial, sans-serif; margin:0; padding:0; background:#0b0b0b; color:#e6e6e6; }
.container { max-width:760px; margin:1.25rem auto; padding:1rem; }
.tab-buttons { display:flex; gap:0.25rem; margin-bottom:1rem; }
.tab-buttons button { flex:1; padding:0.6rem; background:#141414; color:#e6e6e6; border:1px solid #222; cursor:pointer; border-radius:6px; }
.tab-buttons button.active { background:#212121; border-color:#333; }
.tab-content { display:none; }
.tab-content.active { display:block; }
textarea { width:100%; height:140px; margin-bottom:0.75rem; padding:0.6rem; background:#0f0f0f; color:#e6e6e6; border:1px solid #222; border-radius:6px; resize:vertical; }
button.action { padding:0.5rem 0.9rem; background:#1f1f1f; color:#e6e6e6; border:1px solid #2b2b2b; border-radius:6px; cursor:pointer; margin-right:0.4rem; }
.small { font-size:0.85rem; color:#cfcfcf; margin-top:0.5rem; }
.footer { font-size:0.82rem; color:#9a9a9a; margin-top:1rem; }
.code { font-family: monospace; background:#0e0e0e; padding:0.35rem 0.5rem; border-radius:4px; border:1px solid #121212; }
.settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
.settings-grid label { font-size: 0.85rem; color: #cfcfcf; }
.settings-grid select, .settings-grid input { background:#0f0f0f; color:#e6e6e6; border:1px solid #222; padding:0.2rem; border-radius:4px; }
input[type="file"] { font-size: 0.8rem; }
.mode-info { background: #111; border-left: 3px solid #333; padding: 0.5rem; margin: 0.5rem 0; font-size: 0.8rem; }
.efficiency-bar { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; }
.bar { height: 6px; background: #222; border-radius: 3px; flex: 1; position: relative; }
.bar-fill { height: 100%; background: linear-gradient(90deg, #f44, #fa4, #4a4); border-radius: 3px; }
</style>
</head>
<body>
<div class="container">
    <div class="tab-buttons" role="tablist">
        <button id="btnHide" class="active" onclick="showTab(event,'hideTab')">Hide</button>
        <button id="btnFind" onclick="showTab(event,'findTab')">Find</button>
        <button id="btnFile" onclick="showTab(event,'fileTab')">File Mode</button>
    </div>

    <div id="hideTab" class="tab-content active">
        <textarea id="inputText" placeholder="Enter plaintext to hide..."></textarea>
        
        <div class="settings-grid">
            <label>Mode:
                <select id="modeSelect" onchange="updateModeInfo()">
                    <option value="compact">Compact (A-Z + marks)</option>
                    <option value="micro">Micro (minimal chars)</option>
                    <option value="invisible">Invisible (ZW only)</option>
                </select>
            </label>
            <label>Repetition:
                <select id="repSelect">
                    <option value="1">1x</option>
                    <option value="2">2x</option>
                    <option value="3" selected>3x</option>
                    <option value="4">4x</option>
                </select>
            </label>
            <label>Compression:
                <select id="compressSelect">
                    <option value="none">None</option>
                    <option value="basic" selected>Basic</option>
                </select>
            </label>
        </div>
        
        <div id="modeInfo" class="mode-info"></div>
        
        <div style="display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem;">
            <button class="action" onclick="hideText()">Generate</button>
            <button class="action" onclick="copyToClipboard('outputText')">Copy</button>
            <div id="efficiency" class="efficiency-bar" style="margin-left: auto;"></div>
        </div>
        
        <textarea id="outputText" placeholder="Obfuscated output appears here..." readonly></textarea>
        <div class="small" id="outputStats"></div>
    </div>

    <div id="findTab" class="tab-content">
        <textarea id="hiddenInput" placeholder="Paste obfuscated text here..."></textarea>
        <div style="display:flex; gap:0.5rem; margin-bottom:0.5rem;">
            <button class="action" onclick="findText()">Recover text</button>
            <button class="action" onclick="copyToClipboard('recoveredText')">Copy recovered</button>
            <button class="action" onclick="showHexPreview()">Hex preview</button>
        </div>
        <textarea id="recoveredText" placeholder="Recovered text will appear here..." readonly></textarea>
        <div id="report" class="small"></div>
    </div>

    <div id="fileTab" class="tab-content">
        <div style="margin-bottom: 1rem;">
            <label class="small">Upload file to hide:</label>
            <input type="file" id="fileInput" style="margin-top: 0.5rem; width: 100%;">
        </div>
        
        <div class="settings-grid">
            <label>Mode:
                <select id="fileModeSelect">
                    <option value="micro" selected>Micro</option>
                    <option value="invisible">Invisible</option>
                </select>
            </label>
            <label>Repetition:
                <select id="fileRepSelect">
                    <option value="2">2x</option>
                    <option value="3" selected>3x</option>
                    <option value="4">4x</option>
                </select>
            </label>
        </div>
        
        <div style="display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem;">
            <button class="action" onclick="hideFile()">Hide File</button>
            <button class="action" onclick="copyToClipboard('fileOutput')">Copy</button>
            <button class="action" onclick="recoverFile()">Recover File</button>
        </div>
        
        <textarea id="fileOutput" placeholder="File hidden in steganographic text..." readonly style="height: 100px;"></textarea>
        <textarea id="fileRecovery" placeholder="Paste hidden file data to recover..." style="height: 60px;"></textarea>
        
        <div id="fileStats" class="small"></div>
    </div>
</div>

<script>
/* ---------- Enhanced Configuration ---------- */
const COMB_MAP = [
  '\u0300','\u0301','\u0302','\u0303','\u0304','\u0306','\u0307','\u0308',
  '\u030A','\u030B','\u0327','\u0328','\u0338','\u0323','\u035C','\u0361'
];

const ZW_MAP = ['\u200B','\u200C','\u200D','\u2060','\u2061','\u2062','\u2063','\u2064','\u2065','\u2066','\u2067','\u2068','\u2069','\u206A','\u206B','\u206C'];

// Minimal character set for micro mode (common, safe chars)
const MICRO_CHARS = ['a','e','i','o','u','n','r','s','t'];

/* ---------- Utilities ---------- */
function showTab(ev, id){
    document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-buttons button').forEach(b=>b.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    ev.currentTarget.classList.add('active');
    if(id === 'hideTab') updateModeInfo();
}

function updateModeInfo() {
    const mode = document.getElementById('modeSelect').value;
    const info = document.getElementById('modeInfo');
    
    switch(mode) {
        case 'compact':
            info.innerHTML = 'Uses A-Z letters with combining marks. Moderate steganographic strength, good platform compatibility.';
            break;
        case 'micro':
            info.innerHTML = 'Uses only common vowels/consonants (a,e,i,o,u,n,r,s,t) with marks. Maximum efficiency, smallest output.';
            break;
        case 'invisible':
            info.innerHTML = 'Pure zero-width characters only. Completely invisible but may be stripped by some platforms.';
            break;
    }
}

function textToBytes(str) {
    return new TextEncoder().encode(str);
}

function bytesToNibbles(bytes) {
    const n = [];
    for(let b of bytes) {
        n.push((b & 0xF0) >> 4);
        n.push(b & 0x0F);
    }
    return n;
}

function nibblesToBytes(nibbles) {
    const out = [];
    for(let i=0; i+1<nibbles.length; i+=2) {
        out.push((nibbles[i]<<4) | nibbles[i+1]);
    }
    return out;
}

/* Basic compression using simple RLE + dictionary for common patterns */
function basicCompress(bytes) {
    // Simple RLE for repeated bytes
    const compressed = [];
    let i = 0;
    
    while(i < bytes.length) {
        let count = 1;
        while(i + count < bytes.length && bytes[i] === bytes[i + count] && count < 255) {
            count++;
        }
        
        if(count >= 3) {
            // RLE marker (0xFF), count, byte
            compressed.push(0xFF, count, bytes[i]);
            i += count;
        } else {
            // Regular byte, but escape 0xFF
            if(bytes[i] === 0xFF) {
                compressed.push(0xFF, 0x01, 0xFF); // escape sequence
            } else {
                compressed.push(bytes[i]);
            }
            i++;
        }
    }
    
    return compressed;
}

function basicDecompress(bytes) {
    const decompressed = [];
    let i = 0;
    
    while(i < bytes.length) {
        if(bytes[i] === 0xFF && i + 2 < bytes.length) {
            const count = bytes[i + 1];
            const value = bytes[i + 2];
            
            if(count === 1 && value === 0xFF) {
                // Escaped 0xFF
                decompressed.push(0xFF);
            } else {
                // RLE sequence
                for(let j = 0; j < count; j++) {
                    decompressed.push(value);
                }
            }
            i += 3;
        } else {
            decompressed.push(bytes[i]);
            i++;
        }
    }
    
    return decompressed;
}

/* CRC-16-CCITT */
function crc16(bytes) {
    let crc = 0xFFFF;
    for(let b of bytes) {
        crc ^= (b << 8);
        for(let i=0; i<8; i++) {
            if(crc & 0x8000) crc = ((crc << 1) ^ 0x1021) & 0xFFFF;
            else crc = (crc << 1) & 0xFFFF;
        }
    }
    return crc & 0xFFFF;
}

function polyHash(bytes) {
    let h = 0;
    for(let b of bytes) h = ((h * 131) + b) >>> 0;
    return h >>> 0;
}

function fuzzyDigits(bytes) {
    let s = 0;
    for(let b of bytes) s = (s + b) >>> 0;
    let d1 = s % 10;

    let w = 0;
    for(let i=0; i<bytes.length; i++) w = (w + (i+1) * bytes[i]) >>> 0;
    let d2 = w % 10;

    let xr = 0;
    for(let b of bytes) xr ^= b;
    let d3 = xr % 10;

    let c = crc16(bytes);
    let d4 = c % 10;

    let p = polyHash(bytes);
    let d5 = p % 10;

    return `${d1}${d2}${d3}${d4}${d5}`;
}

function nibblesToMarks(nibbles, repetition, useZeroWidth = false) {
    const marks = [];
    const markSet = useZeroWidth ? ZW_MAP : COMB_MAP;
    
    for(const n of nibbles) {
        const mark = markSet[n];
        for(let r=0; r<repetition; r++) marks.push(mark);
    }
    return marks;
}

function marksToVisible(marks, mode) {
    if(mode === 'invisible') {
        return marks.join(''); // Pure zero-width
    }
    
    const parts = [];
    const charSet = mode === 'micro' ? MICRO_CHARS : null;
    
    for(const m of marks) {
        let char;
        if(charSet) {
            char = charSet[Math.floor(Math.random() * charSet.length)];
        } else {
            // Compact mode: A-Z
            char = String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }
        parts.push(char + m);
    }
    
    return parts.join('');
}

function extractMarks(input) {
    const marks = [];
    for(let i=0; i<input.length; i++) {
        const ch = input[i];
        if((ch >= '\u0300' && ch <= '\u036F') || 
           (ch >= '\u200B' && ch <= '\u206C')) {
            marks.push(ch);
        }
    }
    return marks;
}

function marksToNibblesWithMajority(marks, repetition) {
    const nibbles = [];
    for(let i=0; i<marks.length; i += repetition) {
        const slice = marks.slice(i, i+repetition);
        if(slice.length === 0) break;
        
        const counts = new Map();
        for(const s of slice) {
            counts.set(s, (counts.get(s) || 0) + 1);
        }
        
        let winner = null, best = -1;
        for(const [k,v] of counts) {
            if(v > best) { best = v; winner = k; }
        }
        
        let idx = COMB_MAP.indexOf(winner);
        if(idx === -1) idx = ZW_MAP.indexOf(winner);
        if(idx === -1) return null;
        
        nibbles.push(idx);
    }
    return nibbles;
}

function bytesToHex(bytes) {
    return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(' ');
}

function updateEfficiencyDisplay(originalSize, outputSize, compressionRatio) {
    const efficiency = Math.max(0, Math.min(100, (1 - outputSize/originalSize) * 100));
    const efficiencyEl = document.getElementById('efficiency');
    
    efficiencyEl.innerHTML = `
        <span>Efficiency:</span>
        <div class="bar">
            <div class="bar-fill" style="width: ${efficiency}%"></div>
        </div>
        <span>${Math.round(efficiency)}%</span>
    `;
}

/* ---------- Core Hide/Find Functions ---------- */
function hideText() {
    const input = document.getElementById('inputText').value || '';
    if(input.length === 0) return alert('Enter some text to hide');
    
    const mode = document.getElementById('modeSelect').value;
    const repetition = parseInt(document.getElementById('repSelect').value, 10) || 3;
    const compress = document.getElementById('compressSelect').value === 'basic';
    
    let bytes = Array.from(textToBytes(input));
    const originalSize = bytes.length;
    
    // Apply compression if selected
    if(compress) {
        bytes = basicCompress(bytes);
    }
    
    // Add metadata
    const crc = crc16(bytes);
    bytes.push((crc >> 8) & 0xFF);
    bytes.push(crc & 0xFF);
    
    // Add compression flag
    bytes.push(compress ? 1 : 0);
    
    const fuzzy = fuzzyDigits(bytes.slice(0, bytes.length - 3));
    for(const ch of fuzzy) bytes.push(ch.charCodeAt(0));
    
    const nibbles = bytesToNibbles(bytes);
    const useZeroWidth = mode === 'invisible';
    const marks = nibblesToMarks(nibbles, repetition, useZeroWidth);
    const output = marksToVisible(marks, mode);
    
    document.getElementById('outputText').value = output;
    
    // Update stats
    const compressionRatio = compress ? originalSize / bytes.length : 1;
    updateEfficiencyDisplay(originalSize * 8, output.length, compressionRatio); // *8 for character efficiency
    
    const stats = `Original: ${originalSize} bytes, Compressed: ${bytes.length} bytes, Output: ${output.length} chars, Ratio: ${(output.length/originalSize).toFixed(2)}:1`;
    document.getElementById('outputStats').textContent = stats;
}

function findText() {
    const input = document.getElementById('hiddenInput').value || '';
    if(input.length === 0) return alert('Paste obfuscated text here');
    
    const repetition = parseInt(document.getElementById('repSelect').value, 10) || 3;
    
    const marks = extractMarks(input);
    if(!marks || marks.length === 0) return alert('No marks found. Payload may have been stripped.');
    
    const nibbles = marksToNibblesWithMajority(marks, repetition);
    if(!nibbles) return alert('Decoding failed: unknown marks or corruption.');
    
    let bytes = nibblesToBytes(nibbles);
    if(bytes.length < 8) return alert('Payload too short for metadata.');
    
    // Extract metadata (CRC + compression flag + fuzzy signature)
    const metaStart = bytes.length - 8;
    let dataBytes = bytes.slice(0, metaStart);
    const gotCrc = (bytes[metaStart] << 8) | bytes[metaStart+1];
    const isCompressed = bytes[metaStart+2] === 1;
    const gotFuzzyAscii = bytes.slice(metaStart+3, metaStart+8);
    const gotFuzzy = String.fromCharCode(...gotFuzzyAscii);
    
    const calcCrc = crc16(dataBytes);
    
    // Decompress if needed
    if(isCompressed) {
        try {
            dataBytes = basicDecompress(dataBytes);
        } catch(e) {
            return alert('Decompression failed');
        }
    }
    
    const recomputedFuzzy = fuzzyDigits(bytes.slice(0, metaStart));
    
    let fuzzyDistance = 0;
    for(let i=0; i<5; i++) {
        fuzzyDistance += Math.abs(parseInt(gotFuzzy[i],10) - parseInt(recomputedFuzzy[i],10));
    }
    const fuzzySimilarityPct = Math.round((1 - (fuzzyDistance / 45)) * 100);
    
    let recoveredText = '';
    try {
        recoveredText = new TextDecoder().decode(new Uint8Array(dataBytes));
    } catch(e) {
        recoveredText = '[decoding error]';
    }
    
    document.getElementById('recoveredText').value = recoveredText;
    
    const reportEl = document.getElementById('report');
    let report = '';
    report += gotCrc === calcCrc ? 'CRC: OK\n' : `CRC: MISMATCH (expected ${calcCrc.toString(16)}, got ${gotCrc.toString(16)})\n`;
    report += `Compressed: ${isCompressed ? 'Yes' : 'No'}\n`;
    report += `Fuzzy similarity: ${fuzzySimilarityPct}%\n`;
    report += `Recovered ${dataBytes.length} bytes from ${input.length} chars\n`;
    reportEl.textContent = report;
}

/* ---------- File Mode Functions ---------- */
function hideFile() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if(!file) return alert('Select a file first');
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const bytes = new Uint8Array(e.target.result);
        const mode = document.getElementById('fileModeSelect').value;
        const repetition = parseInt(document.getElementById('fileRepSelect').value, 10);
        
        // Add file metadata (name length + name + original size)
        const nameBytes = textToBytes(file.name);
        const metadata = [nameBytes.length, ...nameBytes, 
                         (file.size >> 24) & 0xFF, (file.size >> 16) & 0xFF, 
                         (file.size >> 8) & 0xFF, file.size & 0xFF];
        
        let allBytes = [...metadata, ...bytes];
        
        // Always compress for files
        allBytes = basicCompress(allBytes);
        
        const crc = crc16(allBytes);
        allBytes.push((crc >> 8) & 0xFF, crc & 0xFF, 1); // compression flag = 1
        
        const fuzzy = fuzzyDigits(allBytes.slice(0, allBytes.length - 3));
        for(const ch of fuzzy) allBytes.push(ch.charCodeAt(0));
        
        const nibbles = bytesToNibbles(allBytes);
        const useZeroWidth = mode === 'invisible';
        const marks = nibblesToMarks(nibbles, repetition, useZeroWidth);
        const output = marksToVisible(marks, mode);
        
        document.getElementById('fileOutput').value = output;
        
        const stats = `File: ${file.name} (${file.size} bytes) → ${output.length} chars, Ratio: ${(output.length/file.size).toFixed(2)}:1`;
        document.getElementById('fileStats').textContent = stats;
    };
    
    reader.readAsArrayBuffer(file);
}

function recoverFile() {
    const input = document.getElementById('fileRecovery').value || '';
    if(!input) return alert('Paste hidden file data first');
    
    const repetition = parseInt(document.getElementById('fileRepSelect').value, 10);
    const marks = extractMarks(input);
    if(!marks.length) return alert('No marks found');
    
    const nibbles = marksToNibblesWithMajority(marks, repetition);
    if(!nibbles) return alert('Decoding failed');
    
    let bytes = nibblesToBytes(nibbles);
    if(bytes.length < 8) return alert('Payload too short');
    
    // Extract metadata
    const metaStart = bytes.length - 8;
    let dataBytes = bytes.slice(0, metaStart);
    const gotCrc = (bytes[metaStart] << 8) | bytes[metaStart+1];
    const isCompressed = bytes[metaStart+2] === 1;
    
    if(crc16(dataBytes) !== gotCrc) return alert('CRC check failed - data corrupted');
    
    if(isCompressed) {
        dataBytes = basicDecompress(dataBytes);
    }
    
    // Extract file metadata
    if(dataBytes.length < 6) return alert('Invalid file metadata');
    
    const nameLen = dataBytes[0];
    if(dataBytes.length < 1 + nameLen + 4) return alert('Incomplete file metadata');
    
    const fileName = new TextDecoder().decode(new Uint8Array(dataBytes.slice(1, 1 + nameLen)));
    const fileSize = (dataBytes[1+nameLen] << 24) | (dataBytes[2+nameLen] << 16) | 
                    (dataBytes[3+nameLen] << 8) | dataBytes[4+nameLen];
    
    const fileData = dataBytes.slice(5 + nameLen);
    
    // Create download
    const blob = new Blob([new Uint8Array(fileData)], {type: 'application/octet-stream'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
    
    document.getElementById('fileStats').textContent = `Recovered: ${fileName} (${fileData.length}/${fileSize} bytes)`;
}

/* ---------- Helper Functions ---------- */
function showHexPreview() {
    const input = document.getElementById('hiddenInput').value || '';
    if(!input) return alert('Paste obfuscated text first');
    
    const marks = extractMarks(input);
    if(!marks.length) return alert('No marks found');
    
    const repetition = parseInt(document.getElementById('repSelect').value, 10) || 3;
    const nibbles = marksToNibblesWithMajority(marks, repetition);
    if(!nibbles) return alert('Not enough data to preview');
    
    const bytes = nibblesToBytes(nibbles);
    alert('Hex preview: ' + bytesToHex(bytes));
}

function copyToClipboard(id) {
    const el = document.getElementById(id);
    if(!el) return;
    const text = el.value || el.textContent || '';
    
    if(navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
            el.style.borderColor = '#3a7';
            setTimeout(() => el.style.borderColor = '#222', 400);
        }).catch(() => {
            fallbackCopy(el);
        });
    } else {
        fallbackCopy(el);
    }
}

function fallbackCopy(el) {
    try {
        el.select();
        el.setSelectionRange(0, el.value.length);
        document.execCommand('copy');
        el.style.borderColor = '#3a7';
        setTimeout(() => el.style.borderColor = '#222', 400);
    } catch(e) {
        alert('Copy failed');
    }
}

// Initialize
updateModeInfo();

/* Expose for console testing */
window._stego = {fuzzyDigits, crc16, extractMarks, marksToVisible, basicCompress, basicDecompress};
</script>
</body>
</html>
