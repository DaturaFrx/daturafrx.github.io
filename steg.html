<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Stego Mnemonic</title><style>body{font-family:Inter,Arial,sans-serif;margin:0;padding:0;background:#0b0b0b;color:#e6e6e6}.c{max-width:760px;margin:1.25rem auto;padding:1rem}.tb{display:flex;gap:.25rem;margin-bottom:1rem}.tb button{flex:1;padding:.6rem;background:#141414;color:#e6e6e6;border:1px solid #222;cursor:pointer;border-radius:6px}.tb button.a{background:#212121;border-color:#333}.t{display:none}.t.a{display:block}textarea{width:100%;height:140px;margin-bottom:.75rem;padding:.6rem;background:#0f0f0f;color:#e6e6e6;border:1px solid #222;border-radius:6px;resize:vertical}.act{padding:.5rem .9rem;background:#1f1f1f;color:#e6e6e6;border:1px solid #2b2b2b;border-radius:6px;cursor:pointer;margin-right:.4rem}.s{font-size:.85rem;color:#cfcfcf;margin-top:.5rem}.f{font-size:.82rem;color:#9a9a9a;margin-top:1rem}.code{font-family:monospace;background:#0e0e0e;padding:.35rem .5rem;border-radius:4px;border:1px solid #121212}.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:.5rem;align-items:center;margin-bottom:.5rem}.grid label{font-size:.85rem;color:#cfcfcf}.grid select,.grid input{background:#0f0f0f;color:#e6e6e6;border:1px solid #222;padding:.2rem;border-radius:4px}input[type=file]{font-size:.8rem}.mi{background:#111;border-left:3px solid #333;padding:.5rem;margin:.5rem 0;font-size:.8rem}.eff{display:flex;align-items:center;gap:.5rem;font-size:.8rem}.bar{height:6px;background:#222;border-radius:3px;flex:1;position:relative}.fill{height:100%;background:linear-gradient(90deg,#f44,#fa4,#4a4);border-radius:3px}</style></head><body><div class="c"><div class="tb" role="tablist"><button id="btnHide" class="a" onclick="S.x(event,'hide')">Hide</button><button id="btnFind" onclick="S.x(event,'find')">Find</button><button id="btnFile" onclick="S.x(event,'file')">File Mode</button></div><div id="hide" class="t a"><textarea id="in" placeholder="Enter plaintext to hide..."></textarea><div class="grid"><label>Mode:<select id="mode" onchange="S.m()"><option value="compact">Compact (A-Z + marks)</option><option value="micro">Micro (minimal chars)</option><option value="invisible">Invisible (ZW only)</option></select></label><label>Repetition:<select id="rep"><option value="1">1x</option><option value="2">2x</option><option value="3" selected>3x</option><option value="4">4x</option></select></label><label>Compression:<select id="cmp"><option value="none">None</option><option value="basic" selected>Basic</option></select></label></div><div id="mi" class="mi"></div><div style="display:flex;gap:.5rem;align-items:center;margin-bottom:.5rem"><button class="act" onclick="S.h()">Generate</button><button class="act" onclick="S.cp('out')">Copy</button><div id="eff" class="eff" style="margin-left:auto"></div></div><textarea id="out" placeholder="Obfuscated output appears here..." readonly></textarea><div class="s" id="stats"></div></div><div id="find" class="t"><textarea id="inH" placeholder="Paste obfuscated text here..."></textarea><div style="display:flex;gap:.5rem;margin-bottom:.5rem"><button class="act" onclick="S.f()">Recover text</button><button class="act" onclick="S.cp('rec')">Copy recovered</button><button class="act" onclick="S.hex()">Hex preview</button></div><textarea id="rec" placeholder="Recovered text will appear here..." readonly></textarea><div id="rpt" class="s"></div></div><div id="file" class="t"><div style="margin-bottom:1rem"><label class="s">Upload file to hide:</label><input type="file" id="fin" style="margin-top:.5rem;width:100%"></div><div class="grid"><label>Mode:<select id="fmode"><option value="micro" selected>Micro</option><option value="invisible">Invisible</option></select></label><label>Repetition:<select id="frep"><option value="2">2x</option><option value="3" selected>3x</option><option value="4">4x</option></select></label></div><div style="display:flex;gap:.5rem;align-items:center;margin-bottom:.5rem"><button class="act" onclick="S.hf()">Hide File</button><button class="act" onclick="S.cp('fout')">Copy</button><button class="act" onclick="S.rf()">Recover File</button></div><textarea id="fout" placeholder="File hidden in steganographic text..." readonly style="height:100px"></textarea><textarea id="frec" placeholder="Paste hidden file data to recover..." style="height:60px"></textarea><div id="fstats" class="s"></div></div></div><script>(function(){
"use strict";
const U=Uint8Array,D=TextEncoder,W=TextDecoder,A=Array.from;
const CMB=(()=>{const b=[768,769,770,771,772,774,775,776,778,779,807,808,840,803,860,865];return b.map(x=>String.fromCharCode(x))})();
const ZW=(()=>{const b=[8203,8204,8205,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300];return b.map(x=>String.fromCharCode(x))})();
const MIC=['a','e','i','o','u','n','r','s','t'];
const R=(m)=>document.getElementById(m);
const E=(b)=>new D().encode(b);
const TD=(b)=>new W().decode(b);
const H16=(n)=>n.toString(16).padStart(2,'0');
const B2H=(b)=>A(b).map(H16).join(' ');
const nb=(B)=>{const n=[];for(let i=0;i<B.length;i++){const b=B[i];n.push((b>>>4)&15,b&15)}return n};
const bn=(n)=>{const o=new U((n.length/2)|0);let j=0;for(let i=0;i+1<n.length;i+=2)o[j++]=(n[i]<<4)|n[i+1];return o};
function crc(b){let c=65535;for(let i=0;i<b.length;i++){c^=(b[i]<<8);for(let j=0;j<8;j++)c=(c&32768)?((c<<1)^0x1021)&65535:(c<<1)&65535}return c&65535}
function rle(b){const o=[];for(let i=0;i<b.length;){let k=1;for(;i+k<b.length&&b[i]===b[i+k]&&k<255;k++);if(k>=3){o.push(255,k,b[i]);i+=k}else{o.push(b[i]===255?255: b[i]);if(b[i]===255){o.push(1,255)}i++}}return new U(o)}
function unrle(b){const o=[];for(let i=0;i<b.length;){if(b[i]===255&&i+2<b.length){const k=b[i+1],v=b[i+2];if(k===1&&v===255){o.push(255)}else{for(let j=0;j<k;j++)o.push(v)}i+=3}else{o.push(b[i]);i++}}return new U(o)}
function fzy(b){let s=0,w=0,x=0;for(let i=0;i<b.length;i++){const v=b[i];s=(s+v)>>>0;w=(w+(i+1)*v)>>>0;x^=v}const d1=(s%10),d2=(w%10),d3=(x%10),d4=(crc(b)%10);let p=0;for(let i=0;i<b.length;i++)p=((p*131)+b[i])>>>0;const d5=(p%10);return `${d1}${d2}${d3}${d4}${d5}`}
const K0=(()=>{
  const a=[0x73,0x5c,0x12,0xa9,0x0f,0x44,0xc1,0x9e,0x28,0x66,0x31,0x07,0x99,0x2d,0x41,0xb3];
  const b=[0x25,0x8e,0x3a,0x47,0xe1,0x52,0x6d,0x18,0xc9,0x04,0xaf,0x7b,0x36,0xda,0x80,0x5f];
  return new U(a.map((v,i)=>v^b[15-i]));
})();
async function sha256(buf){const ab=await crypto.subtle.digest('SHA-256',buf.buffer?buf: new U(buf));return new U(ab)}
function xs128(seed){let s0=(seed[0]|seed[1]<<8|seed[2]<<16|seed[3]<<24)>>>0,s1=(seed[4]|seed[5]<<8|seed[6]<<16|seed[7]<<24)>>>0;let s2=(seed[8]|seed[9]<<8|seed[10]<<16|seed[11]<<24)>>>0,s3=(seed[12]|seed[13]<<8|seed[14]<<16|seed[15]<<24)>>>0;function n(){let t=s0^ (s0<<11);s0=s1;s1=s2;s2=s3;s3=(s3^(s3>>>19)^(t^(t>>>8)))>>>0;return (s3>>>0)}return{next:()=>{const v=n();return v>>>0}}}
function maskBytes(b,pr){const o=new U(b.length);for(let i=0;i<b.length;i++){const r=pr.next();const m=((r>>>3)&0xff)^(r&0xff);o[i]=b[i]^m}return o}
function feistel(b,pr){const o=new U(b.length),R=4;for(let i=0;i<b.length;i+=8){let L=0,Rt=0;for(let k=0;k<4;k++){L|=((b[i+k]||0)<<(k*8));Rt|=((b[i+4+k]||0)<<(k*8))}for(let r=0;r<6;r++){const rk=pr.next();const F=((Rt + ((rk&0xffff)>>>0)) ^ (((Rt<<3)|(Rt>>>29))>>>0))>>>0;const nL=Rt>>>0;const nR=(L^F)>>>0;L=nL;Rt=nR}for(let k=0;k<4;k++){o[i+k]= (L>>> (k*8)) &255;o[i+4+k]=(Rt>>> (k*8)) &255} }return o}
function invFeistel(b,pr0){
  const o=new U(b.length);for(let i=0;i<b.length;i+=8){let L=0,Rt=0;for(let k=0;k<4;k++){L|=((b[i+k]||0)<<(k*8));Rt|=((b[i+4+k]||0)<<(k*8))}
    const rks=[];const pr={next:pr0.next};for(let r=0;r<6;r++)rks.push(pr.next());for(let r=5;r>=0;r--){const rk=rks[r];const F=((L + ((rk&0xffff)>>>0)) ^ (((L<<3)|(L>>>29))>>>0))>>>0;const nR=L>>>0;const nL=(Rt^F)>>>0;Rt=nR;L=nL}
    for(let k=0;k<4;k++){o[i+k]= (L>>> (k*8)) &255;o[i+4+k]=(Rt>>> (k*8)) &255}}
  return o}
function interleaveZW(marks,seed){
  let x=0.731, r=3.987, out=[];for(let i=0;i<marks.length;i++){x=r*x*(1-x);const j=(Math.floor(x*7)+i)% (marks.length);out.push(marks[j])}return out}
function n2m(n,rep,zw){const set=zw?ZW:CMB;const out=[];for(const v of n){const m=set[v&15];for(let r=0;r<rep;r++)out.push(m)}return out}
function m2n(m,rep){const ns=[];for(let i=0;i<m.length;i+=rep){const c=m.slice(i,i+rep);const t=new Map();for(const s of c)t.set(s,(t.get(s)||0)+1);let w=null,b=-1;for(const [k,v] of t)if(v>b){b=v;w=k}let idx=CMB.indexOf(w);if(idx===-1)idx=ZW.indexOf(w);if(idx===-1)return null;ns.push(idx)}return ns}
function mv(m,mode){if(mode==='invisible')return m.join('');const parts=[];const cs=mode==='micro'?MIC:null;for(const x of m){const ch=cs?cs[(Math.random()*cs.length)|0]:String.fromCharCode(65+((Math.random()*26)|0));parts.push(ch+x)}return parts.join('')}
function xt(a,b){const n=a.length;const o=new U(n);for(let i=0;i<n;i++)o[i]=a[i]^b[i%b.length];return o}
function gEff(orig,out){const eff=Math.max(0,Math.min(100,(1-out/orig)*100));R('eff').innerHTML=`<span>Efficiency:</span><div class="bar"><div class="fill" style="width:${Math.round(eff)}%"></div></div><span>${Math.round(eff)}%</span>`}
function em(input){
  return input }
const S={x:(ev,id)=>{document.querySelectorAll('.t').forEach(t=>t.classList.remove('a'));document.querySelectorAll('.tb button').forEach(b=>b.classList.remove('a'));R(id).classList.add('a');ev.currentTarget.classList.add('a');if(id==='hide')S.m()},m:()=>{const v=R('mode').value;const i=R('mi');i.textContent=(v==='compact')?'Uses A-Z letters with combining marks. Moderate steganographic strength, good platform compatibility.':(v==='micro')?'Uses only common vowels/consonants (a,e,i,o,u,n,r,s,t) with marks. Maximum efficiency, smallest output.':'Pure zero-width characters only. Completely invisible but may be stripped by some platforms.'},cp:(id)=>{const el=R(id);const t=el.value||el.textContent||'';if(navigator.clipboard&&navigator.clipboard.writeText){navigator.clipboard.writeText(t).then(()=>{el.style.borderColor='#3a7';setTimeout(()=>el.style.borderColor='#222',400)}).catch(()=>fb(el))}else fb(el)},h:async()=>{const txt=R('in').value||'';if(!txt.length)return alert('Enter some text to hide');const mode=R('mode').value;const rep=parseInt(R('rep').value,10)||3;const cmp=R('cmp').value==='basic';let b=new U(E(txt));const orig=b.length; if(cmp)b=rle(b);
  const salt=new U(16);crypto.getRandomValues(salt);const h=await sha256(new U([...salt,...K0,...b]));const pr=xs128(h);const masked=maskBytes(b,pr);const pr2=xs128(h);const perm=feistel(masked,pr2);const final=xt(perm,K0);
  const c=crc(final);const meta=new U([ (c>>>8)&255, c&255, cmp?1:0 ]);const f=E(fzy(final));const packed=new U([...final,...meta,...f,...salt]);const n=nb(packed);const zw=(mode==='invisible');let marks=n2m(n,rep,zw);if(!zw)marks=interleaveZW(marks,h[0]);const out=mv(marks,mode);R('out').value=out;gEff(orig*8,out.length);R('stats').textContent=`Original: ${orig} bytes, Packed: ${packed.length} bytes, Output: ${out.length} chars, Ratio: ${(out.length/orig).toFixed(2)}:1`},f:async()=>{const s=R('inH').value||'';if(!s.length)return alert('Paste obfuscated text here');const rep=parseInt(R('rep').value,10)||3;const m=(()=>{const a=[];for(let i=0;i<s.length;i++){const ch=s[i];if((ch>='\u0300'&&ch<='\u036F')||(ch>='\u200B'&&ch<='\u206C'))a.push(ch)}return a})();if(!m.length)return alert('No marks found. Payload may have been stripped.');const n=m2n(m,rep);if(!n)return alert('Decoding failed: unknown marks or corruption.');let b=bn(n);if(b.length<24)return alert('Payload too short for metadata.');const metaStart=b.length- (2+1+5+16);const core=b.slice(0,metaStart);const gotC=(core=>{const L=core.length;return (b[metaStart]<<8)|b[metaStart+1]})(0);const isC=b[metaStart+2]===1;const gotF=b.slice(metaStart+3,metaStart+8);const salt=b.slice(metaStart+8,metaStart+24);const h=await sha256(new U([...salt,...K0,...core]));const pr2=xs128(h);const inv=xt(core,K0);const pr=xs128(h);const unperm=invFeistel(inv,pr2);const unmask=maskBytes(unperm,pr);if(crc(core)!==((b[metaStart]<<8)|b[metaStart+1])){ /* allow recovery but report */ }
  let data=isC?unrle(unmask):unmask;let out='';try{out=TD(data)}catch(e){out='[decoding error]'}R('rec').value=out;const rf=fzy(core);let d=0;const gf=String.fromCharCode(...gotF);for(let i=0;i<5;i++)d+=Math.abs(parseInt(gf[i],10)-parseInt(rf[i],10));const sim=Math.round((1-(d/45))*100);R('rpt').textContent=`CRC: ${(crc(core)===((b[metaStart]<<8)|b[metaStart+1]))?'OK':'MISMATCH'}\nCompressed: ${isC?'Yes':'No'}\nFuzzy similarity: ${sim}%\nRecovered ${data.length} bytes from ${s.length} chars`},hf:()=>{const fi=R('fin').files[0];if(!fi)return alert('Select a file first');const fr=new FileReader();fr.onload=async(e)=>{const bytes=new U(e.target.result);const mode=R('fmode').value;const rep=parseInt(R('frep').value,10);const name=new U(E(fi.name));const meta=new U([name.length,...name,(fi.size>>>24)&255,(fi.size>>>16)&255,(fi.size>>>8)&255,fi.size&255]);let all=new U([...meta,...bytes]);all=rle(all);const salt=new U(16);crypto.getRandomValues(salt);const h=await sha256(new U([...salt,...K0,...all]));const pr=xs128(h),pr2=xs128(h);const masked=maskBytes(all,pr);const perm=feistel(masked,pr2);const final=xt(perm,K0);const c=crc(final);const trailer=new U([ (c>>>8)&255, c&255, 1 ]);const f=E(fzy(final));const packed=new U([...final,...trailer,...f,...salt]);const n=nb(packed);const zw=(mode==='invisible');let marks=n2m(n,rep,zw);if(!zw)marks=interleaveZW(marks,h[0]);const out=mv(marks,mode);R('fout').value=out;R('fstats').textContent=`File: ${fi.name} (${fi.size} bytes) â†’ ${out.length} chars, Ratio: ${(out.length/fi.size).toFixed(2)}:1`};fr.readAsArrayBuffer(fi)},rf:()=>{const s=R('frec').value||'';if(!s)return alert('Paste hidden file data first');const rep=parseInt(R('frep').value,10);const m=(()=>{const a=[];for(let i=0;i<s.length;i++){const ch=s[i];if((ch>='\u0300'&&ch<='\u036F')||(ch>='\u200B'&&ch<='\u206C'))a.push(ch)}return a})();if(!m.length)return alert('No marks found');const n=m2n(m,rep);if(!n)return alert('Decoding failed');let b=bn(n);if(b.length<24)return alert('Payload too short');const metaStart=b.length-(2+1+5+16);const core=b.slice(0,metaStart);const isC=b[metaStart+2]===1;const salt=b.slice(metaStart+8,metaStart+24);(async()=>{const h=await sha256(new U([...salt,...K0,...core]));const pr=xs128(h),pr2=xs128(h);const inv=xt(core,K0);const unperm=invFeistel(inv,pr2);let data=maskBytes(unperm,pr);if(isC)data=unrle(data);if(data.length<6)return alert('Invalid file metadata');const nlen=data[0];if(data.length<1+nlen+4)return alert('Incomplete file metadata');const fname=TD(data.slice(1,1+nlen));const fsize=(data[1+nlen]<<24)|(data[2+nlen]<<16)|(data[3+nlen]<<8)|data[4+nlen];const fbytes=data.slice(5+nlen);const blob=new Blob([new U(fbytes)],{type:'application/octet-stream'});const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=fname;a.click();URL.revokeObjectURL(url);R('fstats').textContent=`Recovered: ${fname} (${fbytes.length}/${fsize} bytes)`})()},hex:()=>{const s=R('inH').value||'';if(!s)return alert('Paste obfuscated text first');const m=(()=>{const a=[];for(let i=0;i<s.length;i++){const ch=s[i];if((ch>='\u0300'&&ch<='\u036F')||(ch>='\u200B'&&ch<='\u206C'))a.push(ch)}return a})();if(!m.length)return alert('No marks found');const rep=parseInt(R('rep').value,10)||3;const n=m2n(m,rep);if(!n)return alert('Not enough data to preview');const b=bn(n);let d=`Total characters: ${s.length}\n`;d+=`Extracted marks: ${m.length}\n`;d+=`Mark types: ZW=${m.filter(x=>ZW.includes(x)).length}, Combining=${m.filter(x=>CMB.includes(x)).length}\n`;d+=`Nibbles: ${n.length}\n`;d+=`Bytes: ${b.length}\n`;d+=`Hex: ${B2H(b)}`;alert(d)}};window.S=S;S.m();})();</script></body></html>
