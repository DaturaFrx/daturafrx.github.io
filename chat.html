<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chat Cifrado</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: #4ecdc4;
      margin-bottom: 10px;
      font-size: 28px;
    }

    .subtitle {
      text-align: center;
      color: #95a5a6;
      font-size: 14px;
      margin-bottom: 30px;
    }

    .instructions {
      background: #16213e;
      border-left: 4px solid #4ecdc4;
      padding: 20px;
      margin-bottom: 30px;
      border-radius: 8px;
    }

    .instructions h2 {
      color: #4ecdc4;
      font-size: 18px;
      margin-bottom: 15px;
    }

    .instructions ol {
      padding-left: 20px;
    }

    .instructions li {
      margin-bottom: 10px;
      color: #bbb;
    }

    .step {
      background: #0f3460;
      color: #4ecdc4;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
      margin-right: 5px;
    }

    .card {
      background: #16213e;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid #2d3e50;
    }

    .card-title {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 15px;
      color: #4ecdc4;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #95a5a6;
    }

    .status-dot.active {
      background: #2ecc71;
      box-shadow: 0 0 10px #2ecc71;
    }

    label {
      display: block;
      color: #95a5a6;
      font-size: 13px;
      margin-bottom: 8px;
      font-weight: 500;
    }

    input[type="text"],
    textarea {
      width: 100%;
      background: #0f3460;
      border: 2px solid #2d3e50;
      color: #eee;
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus,
    textarea:focus {
      outline: none;
      border-color: #4ecdc4;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    button {
      background: #4ecdc4;
      color: #1a1a2e;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      width: 100%;
      margin-top: 10px;
    }

    button:hover {
      background: #45b7aa;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #e94560;
    }

    button.secondary:hover {
      background: #d63447;
    }

    button.ghost {
      background: transparent;
      border: 2px dashed #2d3e50;
      color: #95a5a6;
    }

    button.ghost:hover {
      border-color: #4ecdc4;
      color: #4ecdc4;
      transform: none;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .button-group button {
      margin-top: 0;
    }

    .output-box {
      background: #0f3460;
      border: 2px solid #2d3e50;
      border-radius: 8px;
      padding: 15px;
      min-height: 80px;
      font-family: monospace;
      font-size: 13px;
      word-break: break-all;
      margin-top: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .output-box:hover {
      border-color: #4ecdc4;
      background: #16213e;
    }

    .output-box.empty {
      color: #5a6c7d;
      font-style: italic;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .file-input-wrapper {
      position: relative;
      margin-top: 10px;
    }

    input[type="file"] {
      width: 100%;
      padding: 12px;
      background: #0f3460;
      border: 2px dashed #2d3e50;
      border-radius: 8px;
      color: #95a5a6;
      cursor: pointer;
    }

    input[type="file"]::-webkit-file-upload-button {
      display: none;
    }

    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: #2ecc71;
      color: white;
      padding: 12px 24px;
      border-radius: 50px;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .toast.show {
      opacity: 1;
    }

    .warning {
      background: #f39c12;
      color: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 13px;
    }

    @media (max-width: 768px) {
      body {
        padding: 15px;
      }

      h1 {
        font-size: 24px;
      }

      .grid {
        grid-template-columns: 1fr;
      }

      .card {
        padding: 20px;
      }

      .instructions {
        padding: 15px;
      }

      .button-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîí Chat Cifrado</h1>
    <div class="subtitle">Encriptaci√≥n de extremo a extremo</div>

    <div class="instructions">
      <h2>üìñ ¬øC√≥mo usar?</h2>
      <ol>
        <li><span class="step">1</span>Comparte tu <strong>Token P√∫blico</strong> con la persona con quien quieres chatear</li>
        <li><span class="step">2</span>P√≠dele su token p√∫blico y p√©galo en el campo <strong>"Token de tu amigo"</strong></li>
        <li><span class="step">3</span>Haz clic en <strong>"Conectar"</strong> - cuando veas el punto verde, ¬°est√°n listos!</li>
        <li><span class="step">4</span>Escribe tu mensaje, haz clic en <strong>"Cifrar"</strong> y env√≠a el texto cifrado por cualquier medio</li>
        <li><span class="step">5</span>Tu amigo pega el texto cifrado y hace clic en <strong>"Descifrar"</strong> para leerlo</li>
      </ol>
    </div>

    <div class="card">
      <div class="card-title">
        <span class="status-dot" id="statusDot"></span>
        <span>Tu Sesi√≥n</span>
      </div>
      
      <label>üîë Tu Token P√∫blico (comp√°rtelo con tu amigo)</label>
      <input type="text" id="myToken" readonly>
      <div class="button-group">
        <button onclick="copyMyToken()">üìã Copiar Token</button>
        <button class="secondary" onclick="regenerateKey()">üîÑ Nuevo Token</button>
      </div>
    </div>

    <div class="card">
      <div class="card-title">ü§ù Conectar con tu amigo</div>
      
      <label>Pega el token p√∫blico de tu amigo aqu√≠</label>
      <input type="text" id="peerToken" placeholder="Pega el token aqu√≠...">
      <button onclick="connectPeer()">‚úÖ Conectar</button>
      <div id="peerStatus" style="color: #95a5a6; font-size: 13px; margin-top: 10px; text-align: center;"></div>
    </div>

    <div id="chatSection" style="display: none;">
      <div class="warning">
        ‚ö†Ô∏è <strong>Importante:</strong> Nunca env√≠es tu token p√∫blico y un mensaje cifrado en el mismo lugar. Env√≠a tu token por un canal (ej: WhatsApp) y los mensajes cifrados por otro (ej: Email).
      </div>

      <div class="grid">
        <div class="card">
          <div class="card-title">üìù Enviar Mensaje</div>
          
          <label>Escribe tu mensaje secreto</label>
          <textarea id="plaintext" placeholder="Hola, este es mi mensaje secreto..."></textarea>
          
          <button onclick="encryptMessage()">üîí Cifrar Mensaje</button>
          
          <label style="margin-top: 20px;">Mensaje cifrado (copia y env√≠a esto)</label>
          <div id="cipherOutput" class="output-box empty" onclick="copyText('cipherOutput')">
            El mensaje cifrado aparecer√° aqu√≠...
          </div>
        </div>

        <div class="card">
          <div class="card-title">üì¨ Recibir Mensaje</div>
          
          <label>Pega el mensaje cifrado que recibiste</label>
          <textarea id="ciphertext" placeholder="Pega el mensaje cifrado aqu√≠..."></textarea>
          
          <button onclick="decryptMessage()">üîì Descifrar Mensaje</button>
          
          <label style="margin-top: 20px;">Mensaje descifrado</label>
          <div id="plainOutput" class="output-box empty" onclick="copyText('plainOutput')">
            El mensaje descifrado aparecer√° aqu√≠...
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">üìé Archivos</div>
        
        <label>Cifrar un archivo</label>
        <input type="file" id="fileToEncrypt">
        <button onclick="encryptFile()">üîí Cifrar Archivo</button>
        
        <div style="height: 20px;"></div>
        
        <label>Descifrar un archivo .enc</label>
        <input type="file" id="fileToDecrypt" accept=".enc">
        <button onclick="decryptFile()">üîì Descifrar Archivo</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

    <script>
      // ========================================
      // Pure JavaScript X25519 Implementation
      // ========================================
      const P = 2n ** 255n - 19n;

      function modP(x) {
        x = x % P;
        return x < 0n ? x + P : x;
      }

      function modPow(base, exp, mod) {
        let result = 1n;
        base = base % mod;
        while (exp > 0n) {
          if (exp % 2n === 1n) result = (result * base) % mod;
          exp = exp >> 1n;
          base = (base * base) % mod;
        }
        return result;
      }

      function modInv(x, p) {
        return modPow(x, p - 2n, p);
      }

      function bytesToBigInt(bytes) {
        let result = 0n;
        for (let i = 0; i < bytes.length; i++) {
          result += BigInt(bytes[i]) << (8n * BigInt(i));
        }
        return result;
      }

      function bigIntToBytes(n) {
        const bytes = new Uint8Array(32);
        for (let i = 0; i < 32; i++) {
          bytes[i] = Number((n >> (8n * BigInt(i))) & 0xffn);
        }
        return bytes;
      }

      function clampPrivateKey(key) {
        const k = new Uint8Array(key);
        k[0] &= 248;
        k[31] &= 127;
        k[31] |= 64;
        return k;
      }

      function x25519(k, u) {
        k = clampPrivateKey(k);
        const kInt = bytesToBigInt(k);
        const uInt = bytesToBigInt(u);

        let x1 = uInt;
        let x2 = 1n;
        let z2 = 0n;
        let x3 = uInt;
        let z3 = 1n;
        let swap = 0n;

        for (let t = 254; t >= 0; t--) {
          const kt = (kInt >> BigInt(t)) & 1n;
          swap ^= kt;

          if (swap) {
            [x2, x3] = [x3, x2];
            [z2, z3] = [z3, z2];
          }
          swap = kt;

          const A = modP(x2 + z2);
          const AA = modP(A * A);
          const B = modP(x2 - z2);
          const BB = modP(B * B);
          const E = modP(AA - BB);
          const C = modP(x3 + z3);
          const D = modP(x3 - z3);
          const DA = modP(D * A);
          const CB = modP(C * B);

          x3 = modP((DA + CB) * (DA + CB));
          z3 = modP(x1 * (DA - CB) * (DA - CB));
          x2 = modP(AA * BB);
          z2 = modP(E * (AA + modP(121665n * E)));
        }

        if (swap) {
          [x2, x3] = [x3, x2];
          [z2, z3] = [z3, z2];
        }

        const result = modP(x2 * modInv(z2, P));
        return bigIntToBytes(result);
      }

      function generateX25519PrivateKey() {
        const key = new Uint8Array(32);
        crypto.getRandomValues(key);
        return key;
      }

      function computeX25519PublicKey(privateKey) {
        const basePoint = new Uint8Array(32);
        basePoint[0] = 9;
        return x25519(privateKey, basePoint);
      }

      function x25519SharedSecret(myPrivate, theirPublic) {
        return x25519(myPrivate, theirPublic);
      }

      // ========================================
      // App State & Utilities
      // ========================================
      let myPrivateKey = null;
      let myPublicKey = null;
      let symKey = null;

      const tv = (id) => document.getElementById(id);
      const toast = tv("copyToast");

      function showToast(msg = "copied", ms = 1200) {
        toast.textContent = msg;
        toast.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => toast.classList.remove("show"), ms);
      }

      function b64urlEncode(u8) {
        const s = btoa(String.fromCharCode(...u8));
        return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      }

      function b64urlDecode(s) {
        s = s.replace(/-/g, "+").replace(/_/g, "/");
        while (s.length % 4) s += "=";
        const bin = atob(s);
        const out = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
        return out;
      }

      function uint16be(n) {
        return new Uint8Array([(n >> 8) & 0xff, n & 0xff]);
      }
      function readUint16be(u8, off) {
        return (u8[off] << 8) | u8[off + 1];
      }

      async function deriveSymmetricKeyFromShared(sharedSecret) {
        const salt = new Uint8Array();
        const info = new TextEncoder().encode("ecdh:aesgcm");
        const hk = await crypto.subtle.importKey(
          "raw",
          sharedSecret,
          "HKDF",
          false,
          ["deriveKey"]
        );
        const aesKey = await crypto.subtle.deriveKey(
          { name: "HKDF", hash: "SHA-256", salt, info },
          hk,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );
        try {
          new Uint8Array(sharedSecret).fill(0);
        } catch (e) {}
        return aesKey;
      }

      async function generateEphemeral() {
        tv("status").textContent = "generating X25519 keypair";
        tv("mobileStatus").textContent = "generating X25519 keypair";

        myPrivateKey = generateX25519PrivateKey();
        myPublicKey = computeX25519PublicKey(myPrivateKey);

        const token = "pub1x" + b64urlEncode(myPublicKey);
        tv("myToken").textContent = token;
        tv("mobileMyToken").textContent = token;
        tv("status").textContent = "ephemeral X25519 ready";
        tv("mobileStatus").textContent = "ephemeral X25519 ready";

        tv("peerState").textContent = "";
        tv("mobilePeerState").textContent = "";
        showOps(false);
      }

      function parsePeerToken(token) {
        if (!token || !token.startsWith("pub1x"))
          throw new Error("invalid token (must start with pub1x)");
        const rawB64 = token.slice(5);
        const raw = b64urlDecode(rawB64);
        if (raw.length !== 32)
          throw new Error("invalid X25519 public key length");
        return raw;
      }

      async function acceptPeerLogic(tokenInput, stateEl, statusEl) {
        try {
          const token = tokenInput.value.trim();
          if (!token) {
            stateEl.textContent = "empty";
            stateEl.className = "bad";
            return;
          }

          let peerPublic;
          try {
            peerPublic = parsePeerToken(token);
          } catch (e) {
            stateEl.textContent = "invalid token";
            stateEl.className = "bad";
            return;
          }

          const sharedSecret = x25519SharedSecret(myPrivateKey, peerPublic);
          symKey = await deriveSymmetricKeyFromShared(sharedSecret.buffer);

          stateEl.textContent = "peer accepted (X25519)";
          stateEl.className = "ok";
          statusEl.textContent = "symmetric key derived";
          showOps(true);
        } catch (e) {
          console.error("acceptPeer error", e);
          stateEl.textContent = "error: " + (e.message || String(e));
          stateEl.className = "bad";
        }
      }

      function showOps(on) {
        tv("ops").style.display = on ? "block" : "none";
      }
      function clearText() {
        tv("ptIn").value = "";
        tv("ctOut").textContent = "";
      }
      function clearCTin() {
        tv("ctIn").value = "";
        tv("ptOut").textContent = "";
      }

      async function encryptText() {
        if (!symKey) {
          alert("no symmetric key");
          return;
        }
        const pt = new TextEncoder().encode(tv("ptIn").value);
        if (pt.length === 0) {
          alert("no plaintext");
          return;
        }
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ct = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          symKey,
          pt
        );
        const payload = new Uint8Array(iv.length + ct.byteLength);
        payload.set(iv, 0);
        payload.set(new Uint8Array(ct), iv.length);
        const txt = b64urlEncode(payload);
        tv("ctOut").textContent = txt;
        try {
          pt.fill(0);
        } catch (e) {}
      }

      async function decryptText() {
        if (!symKey) {
          alert("no key");
          return;
        }
        const s = tv("ctIn").value.trim();
        if (!s) {
          alert("no payload");
          return;
        }
        try {
          const payload = b64urlDecode(s);
          if (payload.length < 12 + 16) {
            tv("ptOut").textContent = "payload too small";
            return;
          }
          const iv = payload.slice(0, 12);
          const ct = payload.slice(12);
          const ptbuf = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            symKey,
            ct
          );
          const pt = new TextDecoder().decode(ptbuf);
          tv("ptOut").textContent = pt;
          try {
            new Uint8Array(ptbuf).fill(0);
          } catch (e) {}
        } catch (e) {
          console.error(e);
          tv("ptOut").textContent = "*** decrypt/auth failed ***";
        }
      }

      async function encryptFile() {
        if (!symKey) {
          alert("no key");
          return;
        }
        const fi = tv("fileEnc").files[0];
        if (!fi) {
          alert("pick a file");
          return;
        }
        const arr = new Uint8Array(await fi.arrayBuffer());
        const fname = new TextEncoder().encode(fi.name);
        if (fname.length > 0xffff) {
          alert("filename too long");
          return;
        }
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ct = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv, additionalData: fname },
          symKey,
          arr
        );
        const header = new Uint8Array(
          2 + fname.length + iv.length + ct.byteLength
        );
        header.set(uint16be(fname.length), 0);
        header.set(fname, 2);
        header.set(iv, 2 + fname.length);
        header.set(new Uint8Array(ct), 2 + fname.length + iv.length);
        const blob = new Blob([header], { type: "application/octet-stream" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fi.name + ".enc";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        try {
          arr.fill(0);
        } catch (e) {}
      }

      async function decryptFile() {
        if (!symKey) {
          alert("no key");
          return;
        }
        const fi = tv("fileDec").files[0];
        if (!fi) {
          alert("pick a file");
          return;
        }
        const buf = new Uint8Array(await fi.arrayBuffer());
        if (buf.length < 2 + 12 + 16) {
          alert("file too small");
          return;
        }
        const namelen = readUint16be(buf, 0);
        if (buf.length < 2 + namelen + 12 + 16) {
          alert("file truncated");
          return;
        }
        const fname = buf.slice(2, 2 + namelen);
        const ivOff = 2 + namelen;
        const iv = buf.slice(ivOff, ivOff + 12);
        const ct = buf.slice(ivOff + 12);
        try {
          const ptbuf = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv, additionalData: fname },
            symKey,
            ct
          );
          const outName = new TextDecoder().decode(fname);
          const blob = new Blob([ptbuf], { type: "application/octet-stream" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = outName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          try {
            new Uint8Array(ptbuf).fill(0);
          } catch (e) {}
        } catch (e) {
          console.error(e);
          alert("decrypt/auth failed");
        }
      }

      function downloadText(filename, text) {
        const b = new Blob([text], { type: "text/plain" });
        const url = URL.createObjectURL(b);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      async function copyText(text) {
        try {
          await navigator.clipboard.writeText(text);
          showToast("copied");
        } catch (e) {
          showToast("copy failed");
        }
      }

      function bindPayloadCopy(elem) {
        elem.addEventListener("click", () => {
          const t = elem.textContent.trim();
          if (t) copyText(t);
        });
        elem.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " ") {
            ev.preventDefault();
            const t = elem.textContent.trim();
            if (t) copyText(t);
          }
        });
      }

      function setupMobileMenu() {
        const menuToggle = tv("mobileMenuToggle");
        const mobilePanel = tv("mobilePeerPanel");

        menuToggle.classList.add("active");
        mobilePanel.classList.add("active");

        menuToggle.addEventListener("click", () => {
          menuToggle.classList.toggle("active");
          mobilePanel.classList.toggle("active");
        });

        mobilePanel.addEventListener("click", (e) => {
          if (e.target === mobilePanel) {
            menuToggle.classList.remove("active");
            mobilePanel.classList.remove("active");
          }
        });
      }

      tv("regen").addEventListener("click", generateEphemeral);
      tv("mobileRegen").addEventListener("click", generateEphemeral);

      tv("copyMy").addEventListener("click", async () => {
        const t = tv("myToken").textContent.trim();
        if (t) copyText(t);
      });
      tv("mobileCopyMy").addEventListener("click", async () => {
        const t = tv("mobileMyToken").textContent.trim();
        if (t) copyText(t);
      });

      tv("downloadPub").addEventListener("click", () => {
        if (tv("myToken").textContent)
          downloadText("pub1.txt", tv("myToken").textContent);
      });
      tv("mobileDownloadPub").addEventListener("click", () => {
        if (tv("mobileMyToken").textContent)
          downloadText("pub1.txt", tv("mobileMyToken").textContent);
      });

      tv("acceptPeer").addEventListener("click", () => {
        acceptPeerLogic(tv("peerToken"), tv("peerState"), tv("status"));
      });
      tv("mobileAcceptPeer").addEventListener("click", () => {
        acceptPeerLogic(
          tv("mobilePeerToken"),
          tv("mobilePeerState"),
          tv("mobileStatus")
        );
        tv("peerToken").value = tv("mobilePeerToken").value;
      });

      tv("encText").addEventListener("click", encryptText);
      tv("clrText").addEventListener("click", clearText);
      tv("decText").addEventListener("click", decryptText);
      tv("clrCT").addEventListener("click", clearCTin);
      tv("encFile").addEventListener("click", encryptFile);
      tv("decFile").addEventListener("click", decryptFile);

      tv("tokenShow").addEventListener("click", () => {
        const box = tv("myToken");
        if (box.style.display === "block") {
          box.style.display = "none";
          tv("tokenShow").textContent = "show token";
        } else {
          box.style.display = "block";
          tv("tokenShow").textContent = "hide token";
        }
      });

      window.addEventListener("DOMContentLoaded", () => {
        bindPayloadCopy(tv("ctOut"));
        bindPayloadCopy(tv("ptOut"));
        bindPayloadCopy(tv("myToken"));
        bindPayloadCopy(tv("mobileMyToken"));
        setupMobileMenu();
      });

      generateEphemeral().catch((e) => {
        console.error(e);
        tv("status").textContent = "init failed";
        tv("mobileStatus").textContent = "init failed";
      });

      window.addEventListener("unload", () => {
        try {
          if (myPrivateKey) myPrivateKey.fill(0);
          if (myPublicKey) myPublicKey.fill(0);
          myPrivateKey = null;
          myPublicKey = null;
          symKey = null;
        } catch (e) {}
      });
    </script>
  </body>
</html>

