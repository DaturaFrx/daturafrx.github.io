<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AES-GCM</title>
    <style>
      :root { color-scheme: dark; --bg:#0b0c0f; --card:#0f1116; --muted:#94a3b8; --text:#e6eef6; --accent:#93c5fd; --ok:#22c55e; --bad:#ef4444; --panel-border:#1f2937; }
      html,body{height:100%;margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
      .wrap{max-width:980px;margin:14px auto;padding:12px;}

      /* Header: desktop shows two columns, mobile stacks and simplifies */
      header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
      .hdr-left, .hdr-right { display:flex;flex-direction:column }
      h1{font-size:18px;margin:0;color:#cfe8ff;font-weight:700}
      .sub{font-size:13px;color:var(--muted);line-height:1.2}
      .subSmall{font-size:12px;color:var(--muted)}

      .card{background:var(--card);border:1px solid var(--panel-border);border-radius:12px;padding:12px;margin-bottom:12px;box-shadow:0 6px 20px rgba(0,0,0,0.35)}
      .row{display:flex;gap:8px;align-items:center}
      label.hint{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}
      input[type=text],textarea,select{width:100%;background:rgba(11,12,16,0.9);color:var(--text);border:1px solid var(--panel-border);border-radius:10px;padding:8px;font-family:monospace;font-size:13px}
      textarea{min-height:84px;resize:vertical}
      button{background:rgba(11,12,16,0.98);color:var(--text);border:1px solid #334155;border-radius:10px;padding:8px 10px;font-size:13px;cursor:pointer}
      button:active{transform:translateY(1px)}
      button.ghost{background:transparent;border:1px dashed #334155}
      .mono{font-family:monospace;white-space:pre-wrap;word-break:break-all}
      .hint{color:var(--muted);font-size:12px}
      .ok{color:var(--ok)}
      .bad{color:var(--bad)}
      .sep{height:1px;background:var(--panel-border);margin:10px 0;border-radius:1px}
      .pill{font-size:12px;border:1px solid var(--panel-border);padding:4px 8px;border-radius:999px;color:var(--muted)}

      .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:10px}
      .col-6{grid-column:span 6}
      .col-12{grid-column:span 12}

      /* PAYLOAD UI — made bolder/larger and clearly visible */
      .payload {
        position:relative;
        background:rgba(9,10,12,0.6);
        border:1px solid #23303b;
        border-radius:10px;
        padding:12px;
        font-family:monospace;
        font-size:15px;
        line-height:1.25;
        font-weight:700;
        max-height:220px;
        overflow:auto;
        cursor:pointer;
        user-select:text;
      }
      .payload:active{opacity:0.98}
      .payload .hintSmall{display:block;color:var(--muted);font-size:11px;margin-bottom:6px}
      .copyToast {
        position:fixed; left:50%; transform:translateX(-50%); bottom:22px;
        background:#0f1724;color:var(--text);border:1px solid rgba(255,255,255,0.03);
        padding:8px 12px;border-radius:999px;font-size:13px;box-shadow:0 8px 24px rgba(0,0,0,0.5);opacity:0;pointer-events:none;transition:opacity .18s ease;
      }
      .copyToast.show{opacity:1;pointer-events:auto}

      /* token collapse for mobile to save space */
      .tokenWrap{display:flex;gap:8px;align-items:center}
      .tokenBox{flex:1;padding:8px;border-radius:8px;background:rgba(11,12,16,0.6);border:1px solid var(--panel-border);font-family:monospace;font-size:13px;overflow:auto}
      .tokenToggle{display:none}

      /* compact mobile adjustments for density and an alternate UI layout */
      @media (max-width:720px){
        .wrap{padding:8px;margin:8px auto}
        header{flex-direction:column;align-items:flex-start;gap:8px}
        .hdr-right{align-self:stretch}
        h1{font-size:16px}
        .sub{font-size:13px}
        .subSmall{font-size:12px}
        .subSmall.right{font-size:13px}

        /* hide the long token by default on mobile; show the small toggle */
        .tokenBox{display:none}
        .tokenToggle{display:inline-block}

        .grid{grid-template-columns:1fr}
        .col-6{grid-column:span 1}
        .payload{font-size:16px; font-weight:800; max-height:180px; padding:10px}
        .card{padding:10px;border-radius:10px}
        input[type=text],textarea{font-size:15px;padding:10px;border-radius:8px}
        button{padding:10px;border-radius:10px;font-size:14px}
      }

      footer{font-size:12px;color:var(--muted);margin-top:8px}
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="hdr-left">
          <h1>EncChat</h1>
          <div class="sub">P-256 · HKDF-SHA256 · AES-GCM</div>
        </div>
       </header>

      <section class="card">
        <div class="row"><span class="pill">session</span><div id="status" class="hint">initializing</div></div>
        <div class="sep"></div>
        <div class="grid">
          <div class="col-12">
            <label class="hint">your ephemeral public token</label>
            <div class="tokenWrap">
              <div id="myToken" class="mono tokenBox" title="Tap to copy public token"></div>
              <button id="tokenShow" class="tokenToggle">show token</button>
              <button id="copyMy">copy token</button>
              <button id="regen">regenerate</button>
              <button id="downloadPub" class="ghost">download .txt</button>
            </div>
          </div>

          <div class="col-12">
            <label class="hint">paste peer public token (pub1x… or pub1p…)</label>
            <input id="peerToken" type="text" placeholder="pub1x… or pub1p…" />
            <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
              <button id="acceptPeer">accept peer</button>
              <div id="peerState" class="hint"></div>
            </div>
          </div>
        </div>
      </section>

      <section id="ops" class="card" style="display:none">
        <div class="row"><span class="pill">ops</span><div class="hint">key established</div></div>
        <div class="sep"></div>
        <div class="grid">
          <div class="col-6">
            <label class="hint">encrypt text</label>
            <textarea id="ptIn" placeholder="message"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="encText">encrypt</button>
              <button id="clrText">clear</button>
            </div>
            <div style="margin-top:8px">
              <div class="hintSmall" style="color:var(--muted);font-size:12px;margin-bottom:6px">encrypted payload - tap the box to copy</div>
              <div id="ctOut" class="payload mono" tabindex="0" title="Tap to copy encrypted payload"></div>
            </div>
          </div>

          <div class="col-6">
            <label class="hint">decrypt payload</label>
            <textarea id="ctIn" placeholder="paste payload"></textarea>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="decText">decrypt</button>
              <button id="clrCT">clear</button>
            </div>
            <div style="margin-top:8px">
              <div class="hintSmall" style="color:var(--muted);font-size:12px;margin-bottom:6px">decrypted text - tap the box to copy</div>
              <div id="ptOut" class="payload mono" tabindex="0" title="Tap to copy plaintext"></div>
            </div>
          </div>

          <div class="col-12">
            <div class="sep"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
              <div style="flex:1 1 280px">
                <label class="hint">encrypt file → download <code>.enc</code></label>
                <input id="fileEnc" type="file" />
              </div>
              <div style="display:flex;gap:8px;align-items:center">
                <button id="encFile">encrypt file</button>
              </div>
            </div>

            <div style="height:10px"></div>

            <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
              <div style="flex:1 1 280px">
                <label class="hint">decrypt <code>.enc</code> → download original file</label>
                <input id="fileDec" type="file" />
              </div>
              <div style="display:flex;gap:8px;align-items:center">
                <button id="decFile">decrypt file</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <footer class="card">
        <div class="hint">Notes: token header encodes curve: pub1x = X25519, pub1p = P-256. Everything runs locally in the browser. Filenames are authenticated but not secret.</div>
      </footer>
    </div>

    <div id="copyToast" class="copyToast">copied</div>

    <script>
      // core crypto unchanged: adaptive X25519 / P-256, HKDF-SHA256 -> AES-GCM
      let myKeyPair = null;
      let myPubRaw = null;
      let symKey = null;
      let curveInUse = null;

      const tv = id => document.getElementById(id);
      const toast = tv('copyToast');

      function showToast(msg='copied', ms=1200){
        toast.textContent = msg;
        toast.classList.add('show');
        clearTimeout(toast._t);
        toast._t = setTimeout(()=>toast.classList.remove('show'), ms);
      }

      function b64urlEncode(u8){
        const s = btoa(String.fromCharCode(...u8));
        return s.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      }
      function b64urlDecode(s){
        s = s.replace(/-/g,'+').replace(/_/g,'/');
        while(s.length % 4) s += '=';
        const bin = atob(s);
        const out = new Uint8Array(bin.length);
        for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
        return out;
      }
      function uint16be(n){ return new Uint8Array([ (n>>8)&0xff, n&0xff ]); }
      function readUint16be(u8, off){ return (u8[off]<<8) | u8[off+1]; }
      function arrayBufferSliceOf(u8){ if(u8.buffer && (u8.byteOffset !== 0 || u8.byteLength !== u8.buffer.byteLength)) return u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength); return u8.buffer || u8; }

      async function detectX25519Support(){
        try{
          const kp = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'X25519'}, true, ['deriveBits']);
          const pub = await crypto.subtle.exportKey('raw', kp.publicKey);
          const peer = await crypto.subtle.importKey('raw', pub, {name:'ECDH', namedCurve:'X25519'}, false, []);
          const secret = await crypto.subtle.deriveBits({name:'ECDH', public: peer}, kp.privateKey, 256);
          try{ if(secret instanceof ArrayBuffer) new Uint8Array(secret).fill(0); }catch(e){}
          return true;
        }catch(e){ return false; }
      }

      async function generateEphemeral(){
        tv('status').textContent = 'detecting curve support';
        const haveX = await detectX25519Support();
        if(haveX){
          curveInUse = 'X25519';
          myKeyPair = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'X25519'}, true, ['deriveBits']);
          const rawPub = new Uint8Array(await crypto.subtle.exportKey('raw', myKeyPair.publicKey));
          myPubRaw = rawPub;
          tv('myToken').textContent = 'pub1x' + b64urlEncode(rawPub);
          tv('status').textContent = 'ephemeral X25519 ready';
        }else{
          curveInUse = 'P-256';
          myKeyPair = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveBits']);
          const rawPub = new Uint8Array(await crypto.subtle.exportKey('raw', myKeyPair.publicKey));
          myPubRaw = rawPub;
          tv('myToken').textContent = 'pub1p' + b64urlEncode(rawPub);
          tv('status').textContent = 'ephemeral P-256 ready';
        }
        tv('peerState').textContent = '';
        showOps(false);
      }

      function parsePeerToken(token){
        if(!token || !token.startsWith('pub1')) throw new Error('bad prefix');
        const rest = token.slice(4);
        const tag = rest[0];
        const rawB64 = rest.slice(1);
        const raw = b64urlDecode(rawB64);
        if(tag === 'x' && raw.length === 32) return {curve:'X25519', raw};
        if(tag === 'p' && raw.length === 65) return {curve:'P-256', raw};
        throw new Error('unsupported token or invalid length');
      }

      async function importPeerPublic(parsed){
        const ab = arrayBufferSliceOf(parsed.raw);
        if(parsed.curve === 'X25519'){
          try{ return await crypto.subtle.importKey('raw', ab, {name:'ECDH', namedCurve:'X25519'}, false, []); }catch(e){}
          try{ return await crypto.subtle.importKey('raw', ab, {name:'X25519'}, false, []); }catch(e){}
          throw new Error('importKey X25519 failed');
        }else{
          return await crypto.subtle.importKey('raw', ab, {name:'ECDH', namedCurve:'P-256'}, false, []);
        }
      }

      async function deriveSymmetricKeyFromShared(sharedBitsArrayBuffer){
        const salt = new Uint8Array();
        const info = new TextEncoder().encode('ecdh:aesgcm');
        const hk = await crypto.subtle.importKey('raw', sharedBitsArrayBuffer, 'HKDF', false, ['deriveKey']);
        const aesKey = await crypto.subtle.deriveKey({name:'HKDF', hash:'SHA-256', salt, info}, hk, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
        try{ if(sharedBitsArrayBuffer instanceof ArrayBuffer) new Uint8Array(sharedBitsArrayBuffer).fill(0); }catch(e){}
        return aesKey;
      }

      async function acceptPeer(){
        try{
          const token = tv('peerToken').value.trim();
          if(!token){ tv('peerState').textContent='empty'; tv('peerState').className='bad'; return; }
          let parsed;
          try{ parsed = parsePeerToken(token); }catch(e){ tv('peerState').textContent='invalid token'; tv('peerState').className='bad'; return; }

          if(curveInUse === parsed.curve){
            let peerKey;
            try{ peerKey = await importPeerPublic(parsed); }catch(e){ tv('peerState').textContent='import failed'; tv('peerState').className='bad'; return; }

            if(parsed.curve === 'X25519'){
              try{
                const bits = await crypto.subtle.deriveBits({name:'ECDH', public: peerKey}, myKeyPair.privateKey, 256);
                symKey = await deriveSymmetricKeyFromShared(bits);
                tv('peerState').textContent = 'peer accepted (X25519)'; tv('status').textContent='symmetric key derived'; showOps(true); return;
              }catch(e1){
                try{ symKey = await crypto.subtle.deriveKey({name:'ECDH', public: peerKey}, myKeyPair.privateKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']); tv('peerState').textContent='peer accepted (X25519 deriveKey)'; tv('status').textContent='symmetric key derived'; showOps(true); return;}catch(e2){}
                try{
                  const salt = new Uint8Array(); const info = new TextEncoder().encode('ecdh:aesgcm');
                  const hkKey = await crypto.subtle.deriveKey({name:'ECDH', public: peerKey}, myKeyPair.privateKey, {name:'HKDF', hash:'SHA-256', salt, info}, false, ['deriveKey']);
                  symKey = await crypto.subtle.deriveKey({name:'HKDF', hash:'SHA-256', salt, info}, hkKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
                  tv('peerState').textContent='peer accepted (X25519 alt)'; tv('status').textContent='symmetric key derived'; showOps(true); return;
                }catch(e3){}
              }
              tv('peerState').textContent='derive failed (X25519)'; tv('peerState').className='bad'; return;
            }

            if(parsed.curve === 'P-256'){
              try{
                const bits = await crypto.subtle.deriveBits({name:'ECDH', public: peerKey}, myKeyPair.privateKey, 256);
                symKey = await deriveSymmetricKeyFromShared(bits);
                tv('peerState').textContent='peer accepted (P-256)'; tv('status').textContent='symmetric key derived'; showOps(true); return;
              }catch(e1){
                try{ symKey = await crypto.subtle.deriveKey({name:'ECDH', public: peerKey}, myKeyPair.privateKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']); tv('peerState').textContent='peer accepted (P-256 deriveKey)'; tv('status').textContent='symmetric key derived'; showOps(true); return;}catch(e2){ tv('peerState').textContent='derive failed (P-256)'; tv('peerState').className='bad'; return; }
              }
            }
          }

          // curve mismatch: try generating tmp key on peer curve and derive
          try{
            if(parsed.curve === 'X25519'){
              const tmpKP = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'X25519'}, true, ['deriveBits']);
              const peerKey = await importPeerPublic(parsed);
              const bits = await crypto.subtle.deriveBits({name:'ECDH', public: peerKey}, tmpKP.privateKey, 256);
              symKey = await deriveSymmetricKeyFromShared(bits);
              tv('peerState').textContent='peer accepted (tmp X25519 key)'; tv('status').textContent='symmetric key derived (tmp)'; showOps(true); return;
            }else{
              const tmpKP = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveBits']);
              const peerKey = await importPeerPublic(parsed);
              const bits = await crypto.subtle.deriveBits({name:'ECDH', public: peerKey}, tmpKP.privateKey, 256);
              symKey = await deriveSymmetricKeyFromShared(bits);
              tv('peerState').textContent='peer accepted (tmp P-256 key)'; tv('status').textContent='symmetric key derived (tmp)'; showOps(true); return;
            }
          }catch(e){ console.warn('mutual fallback failed', e); }

          tv('peerState').textContent='derive failed: incompatible engines'; tv('peerState').className='bad';
        }catch(e){
          console.error('acceptPeer unexpected', e);
          tv('peerState').textContent = 'error: ' + (e && e.message ? e.message : String(e)); tv('peerState').className='bad';
        }
      }

      function showOps(on){ tv('ops').style.display = on ? 'block' : 'none'; }
      function clearText(){ tv('ptIn').value=''; tv('ctOut').textContent=''; }
      function clearCTin(){ tv('ctIn').value=''; tv('ptOut').textContent=''; }

      async function encryptText(){
        if(!symKey){ alert('no symmetric key'); return; }
        const pt = new TextEncoder().encode(tv('ptIn').value);
        if(pt.length===0){ alert('no plaintext'); return; }
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, symKey, pt);
        const payload = new Uint8Array(iv.length + ct.byteLength);
        payload.set(iv,0); payload.set(new Uint8Array(ct), iv.length);
        const txt = b64urlEncode(payload);
        tv('ctOut').textContent = txt;
        try{ (new Uint8Array(pt)).fill(0); }catch(e){}
      }

      async function decryptText(){
        if(!symKey){ alert('no key'); return; }
        const s = tv('ctIn').value.trim();
        if(!s){ alert('no payload'); return; }
        try{
          const payload = b64urlDecode(s);
          if(payload.length < 12+16){ tv('ptOut').textContent='payload too small'; return; }
          const iv = payload.slice(0,12);
          const ct = payload.slice(12);
          const ptbuf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, symKey, ct);
          const pt = new TextDecoder().decode(ptbuf);
          tv('ptOut').textContent = pt;
          try{ (new Uint8Array(ptbuf)).fill(0); }catch(e){}
        }catch(e){ console.error(e); tv('ptOut').textContent='*** decrypt/auth failed ***'; }
      }

      async function encryptFile(){
        if(!symKey){ alert('no key'); return; }
        const fi = tv('fileEnc').files[0];
        if(!fi){ alert('pick a file'); return; }
        const arr = new Uint8Array(await fi.arrayBuffer());
        const fname = new TextEncoder().encode(fi.name);
        if(fname.length > 0xFFFF){ alert('filename too long'); return; }
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv, additionalData: fname}, symKey, arr);
        const header = new Uint8Array(2 + fname.length + iv.length + ct.byteLength);
        header.set(uint16be(fname.length), 0);
        header.set(fname, 2);
        header.set(iv, 2 + fname.length);
        header.set(new Uint8Array(ct), 2 + fname.length + iv.length);
        const blob = new Blob([header], {type:'application/octet-stream'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = fi.name + '.enc'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        try{ (new Uint8Array(arr)).fill(0); }catch(e){}
      }

      async function decryptFile(){
        if(!symKey){ alert('no key'); return; }
        const fi = tv('fileDec').files[0];
        if(!fi){ alert('pick a file'); return; }
        const buf = new Uint8Array(await fi.arrayBuffer());
        if(buf.length < 2+12+16){ alert('file too small'); return; }
        const namelen = readUint16be(buf,0);
        if(buf.length < 2 + namelen + 12 + 16){ alert('file truncated'); return; }
        const fname = buf.slice(2, 2+namelen);
        const ivOff = 2 + namelen;
        const iv = buf.slice(ivOff, ivOff+12);
        const ct = buf.slice(ivOff+12);
        try{
          const ptbuf = await crypto.subtle.decrypt({name:'AES-GCM', iv, additionalData: fname}, symKey, ct);
          const outName = new TextDecoder().decode(fname);
          const blob = new Blob([ptbuf], {type:'application/octet-stream'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = outName; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          try{ (new Uint8Array(ptbuf)).fill(0); }catch(e){}
        }catch(e){ console.error(e); alert('decrypt/auth failed'); }
      }

      function downloadText(filename, text){ const b = new Blob([text], {type:'text/plain'}); const url = URL.createObjectURL(b); const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url); }

      // copy helpers bound to payload elements — click/tap the payload itself copies
      async function copyText(text){ try{ await navigator.clipboard.writeText(text); showToast('copied'); }catch(e){ showToast('copy failed'); } }
      function bindPayloadCopy(elem){
        elem.addEventListener('click', ()=>{ const t = elem.textContent.trim(); if(t) copyText(t); });
        elem.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); const t = elem.textContent.trim(); if(t) copyText(t); } });
      }

      // wire UI
      tv('regen').addEventListener('click', generateEphemeral);
      tv('copyMy').addEventListener('click', async ()=>{ const t = tv('myToken').textContent.trim(); if(t) { try{ await navigator.clipboard.writeText(t); showToast('token copied'); }catch(e){ showToast('copy failed'); } }});
      tv('downloadPub').addEventListener('click', ()=>{ if(tv('myToken').textContent) downloadText('pub1.txt', tv('myToken').textContent); });
      tv('acceptPeer').addEventListener('click', acceptPeer);
      tv('encText').addEventListener('click', encryptText);
      tv('clrText').addEventListener('click', clearText);
      tv('decText').addEventListener('click', decryptText);
      tv('clrCT').addEventListener('click', clearCTin);
      tv('encFile').addEventListener('click', encryptFile);
      tv('decFile').addEventListener('click', decryptFile);

      // token toggle for mobile
      tv('tokenShow').addEventListener('click', ()=>{
        const box = tv('myToken');
        if(box.style.display === 'block'){ box.style.display = 'none'; tv('tokenShow').textContent = 'show token'; }
        else{ box.style.display = 'block'; tv('tokenShow').textContent = 'hide token'; }
      });

      // bind payload copy once DOM ready
      window.addEventListener('DOMContentLoaded', ()=>{
        bindPayloadCopy(tv('ctOut'));
        bindPayloadCopy(tv('ptOut'));
      });

      generateEphemeral().catch(e=>{ console.error(e); tv('status').textContent = 'init failed'; });

      window.addEventListener('unload', ()=>{ try{ if(myPubRaw) myPubRaw.fill(0); myPubRaw = null; symKey = null; myKeyPair = null; }catch(e){} });
    </script>
  </body>
</html>
