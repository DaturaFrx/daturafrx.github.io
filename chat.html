<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chat Cifrado</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: #4ecdc4;
      margin-bottom: 10px;
      font-size: 28px;
    }

    .subtitle {
      text-align: center;
      color: #95a5a6;
      font-size: 14px;
      margin-bottom: 30px;
    }

    .instructions {
      background: #16213e;
      border-left: 4px solid #4ecdc4;
      padding: 20px;
      margin-bottom: 30px;
      border-radius: 8px;
    }

    .instructions h2 {
      color: #4ecdc4;
      font-size: 18px;
      margin-bottom: 15px;
    }

    .instructions ol {
      padding-left: 20px;
    }

    .instructions li {
      margin-bottom: 10px;
      color: #bbb;
    }

    .step {
      background: #0f3460;
      color: #4ecdc4;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
      margin-right: 5px;
    }

    .card {
      background: #16213e;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid #2d3e50;
    }

    .card-title {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 15px;
      color: #4ecdc4;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #95a5a6;
    }

    .status-dot.active {
      background: #2ecc71;
      box-shadow: 0 0 10px #2ecc71;
    }

    label {
      display: block;
      color: #95a5a6;
      font-size: 13px;
      margin-bottom: 8px;
      font-weight: 500;
    }

    input[type="text"],
    textarea {
      width: 100%;
      background: #0f3460;
      border: 2px solid #2d3e50;
      color: #eee;
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus,
    textarea:focus {
      outline: none;
      border-color: #4ecdc4;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    button {
      background: #4ecdc4;
      color: #1a1a2e;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      width: 100%;
      margin-top: 10px;
    }

    button:hover {
      background: #45b7aa;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #e94560;
    }

    button.secondary:hover {
      background: #d63447;
    }

    button.ghost {
      background: transparent;
      border: 2px dashed #2d3e50;
      color: #95a5a6;
    }

    button.ghost:hover {
      border-color: #4ecdc4;
      color: #4ecdc4;
      transform: none;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .button-group button {
      margin-top: 0;
    }

    .output-box {
      background: #0f3460;
      border: 2px solid #2d3e50;
      border-radius: 8px;
      padding: 15px;
      min-height: 80px;
      font-family: monospace;
      font-size: 13px;
      word-break: break-all;
      margin-top: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .output-box:hover {
      border-color: #4ecdc4;
      background: #16213e;
    }

    .output-box.empty {
      color: #5a6c7d;
      font-style: italic;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    input[type="file"] {
      width: 100%;
      padding: 12px;
      background: #0f3460;
      border: 2px dashed #2d3e50;
      border-radius: 8px;
      color: #95a5a6;
      cursor: pointer;
    }

    input[type="file"]::-webkit-file-upload-button {
      display: none;
    }

    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: #2ecc71;
      color: white;
      padding: 12px 24px;
      border-radius: 50px;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
    }

    .warning {
      background: #f39c12;
      color: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 13px;
    }

    @media (max-width: 768px) {
      body {
        padding: 15px;
      }

      h1 {
        font-size: 24px;
      }

      .grid {
        grid-template-columns: 1fr;
      }

      .card {
        padding: 20px;
      }

      .instructions {
        padding: 15px;
      }

      .button-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîí Chat Cifrado</h1>
    <div class="subtitle">X25519 ¬∑ HKDF-SHA256 ¬∑ AES-GCM</div>

    <div class="instructions">
      <h2>üìñ ¬øC√≥mo usar?</h2>
      <ol>
        <li><span class="step">1</span>Comparte tu <strong>Token P√∫blico</strong> con la persona con quien quieres chatear</li>
        <li><span class="step">2</span>P√≠dele su token p√∫blico y p√©galo en el campo <strong>"Token de tu amigo"</strong></li>
        <li><span class="step">3</span>Haz clic en <strong>"Conectar"</strong> - cuando veas el punto verde, ¬°est√°n listos!</li>
        <li><span class="step">4</span>Escribe tu mensaje, haz clic en <strong>"Cifrar"</strong> y env√≠a el texto cifrado por cualquier medio</li>
        <li><span class="step">5</span>Tu amigo pega el texto cifrado y hace clic en <strong>"Descifrar"</strong> para leerlo</li>
      </ol>
    </div>

    <div class="card">
      <div class="card-title">
        <span class="status-dot" id="statusDot"></span>
        <span id="status">Inicializando...</span>
      </div>
      
      <label>üîë Tu Token P√∫blico (comp√°rtelo con tu amigo)</label>
      <div class="output-box" id="myToken" onclick="copyMyToken()" style="cursor: pointer;">
        Generando token...
      </div>
      <div class="button-group">
        <button onclick="copyMyToken()">üìã Copiar Token</button>
        <button class="secondary" onclick="regenerateKey()">üîÑ Nuevo Token</button>
        <button class="ghost" onclick="downloadPubToken()">üíæ Descargar .txt</button>
      </div>
    </div>

    <div class="card">
      <div class="card-title">ü§ù Conectar con tu amigo</div>
      
      <label>Pega el token p√∫blico de tu amigo aqu√≠ (pub1x...)</label>
      <input type="text" id="peerToken" placeholder="pub1x...">
      <button onclick="connectPeer()">‚úÖ Conectar</button>
      <div id="peerState" style="color: #95a5a6; font-size: 13px; margin-top: 10px; text-align: center;"></div>
    </div>

    <div id="ops" style="display: none;">
      <div class="warning">
        ‚ö†Ô∏è <strong>Importante:</strong> Nunca env√≠es tu token p√∫blico y un mensaje cifrado en el mismo lugar. Env√≠a tu token por un canal (ej: WhatsApp) y los mensajes cifrados por otro (ej: Email).
      </div>

      <div class="grid">
        <div class="card">
          <div class="card-title">üìù Enviar Mensaje</div>
          
          <label>Escribe tu mensaje secreto</label>
          <textarea id="ptIn" placeholder="Hola, este es mi mensaje secreto..."></textarea>
          
          <div class="button-group">
            <button onclick="encryptText()">üîí Cifrar</button>
            <button class="ghost" onclick="clearText()">üóëÔ∏è Limpiar</button>
          </div>
          
          <label style="margin-top: 20px;">Mensaje cifrado (haz clic para copiar)</label>
          <div id="ctOut" class="output-box empty" onclick="copyOutput('ctOut')">
            El mensaje cifrado aparecer√° aqu√≠...
          </div>
        </div>

        <div class="card">
          <div class="card-title">üì¨ Recibir Mensaje</div>
          
          <label>Pega el mensaje cifrado que recibiste</label>
          <textarea id="ctIn" placeholder="Pega el mensaje cifrado aqu√≠..."></textarea>
          
          <div class="button-group">
            <button onclick="decryptText()">üîì Descifrar</button>
            <button class="ghost" onclick="clearCTin()">üóëÔ∏è Limpiar</button>
          </div>
          
          <label style="margin-top: 20px;">Mensaje descifrado (haz clic para copiar)</label>
          <div id="ptOut" class="output-box empty" onclick="copyOutput('ptOut')">
            El mensaje descifrado aparecer√° aqu√≠...
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">üìé Cifrar/Descifrar Archivos</div>
        
        <label>Cifrar un archivo</label>
        <input type="file" id="fileEnc">
        <button onclick="encryptFile()">üîí Cifrar y Descargar .enc</button>
        
        <div style="height: 20px;"></div>
        
        <label>Descifrar un archivo .enc</label>
        <input type="file" id="fileDec" accept=".enc">
        <button onclick="decryptFile()">üîì Descifrar y Descargar</button>
      </div>
    </div>
  </div>

  <div id="copyToast" class="toast">Copiado</div>

  <script>
    // ========================================
    // Pure JavaScript X25519 Implementation
    // ========================================
    const P = 2n ** 255n - 19n;

    function modP(x) {
      x = x % P;
      return x < 0n ? x + P : x;
    }

    function modPow(base, exp, mod) {
      let result = 1n;
      base = base % mod;
      while (exp > 0n) {
        if (exp % 2n === 1n) result = (result * base) % mod;
        exp = exp >> 1n;
        base = (base * base) % mod;
      }
      return result;
    }

    function modInv(x, p) {
      return modPow(x, p - 2n, p);
    }

    function bytesToBigInt(bytes) {
      let result = 0n;
      for (let i = 0; i < bytes.length; i++) {
        result += BigInt(bytes[i]) << (8n * BigInt(i));
      }
      return result;
    }

    function bigIntToBytes(n) {
      const bytes = new Uint8Array(32);
      for (let i = 0; i < 32; i++) {
        bytes[i] = Number((n >> (8n * BigInt(i))) & 0xffn);
      }
      return bytes;
    }

    function clampPrivateKey(key) {
      const k = new Uint8Array(key);
      k[0] &= 248;
      k[31] &= 127;
      k[31] |= 64;
      return k;
    }

    function x25519(k, u) {
      k = clampPrivateKey(k);
      const kInt = bytesToBigInt(k);
      const uInt = bytesToBigInt(u);

      let x1 = uInt;
      let x2 = 1n;
      let z2 = 0n;
      let x3 = uInt;
      let z3 = 1n;
      let swap = 0n;

      for (let t = 254; t >= 0; t--) {
        const kt = (kInt >> BigInt(t)) & 1n;
        swap ^= kt;

        if (swap) {
          [x2, x3] = [x3, x2];
          [z2, z3] = [z3, z2];
        }
        swap = kt;

        const A = modP(x2 + z2);
        const AA = modP(A * A);
        const B = modP(x2 - z2);
        const BB = modP(B * B);
        const E = modP(AA - BB);
        const C = modP(x3 + z3);
        const D = modP(x3 - z3);
        const DA = modP(D * A);
        const CB = modP(C * B);

        x3 = modP((DA + CB) * (DA + CB));
        z3 = modP(x1 * (DA - CB) * (DA - CB));
        x2 = modP(AA * BB);
        z2 = modP(E * (AA + modP(121665n * E)));
      }

      if (swap) {
        [x2, x3] = [x3, x2];
        [z2, z3] = [z3, z2];
      }

      const result = modP(x2 * modInv(z2, P));
      return bigIntToBytes(result);
    }

    function generateX25519PrivateKey() {
      const key = new Uint8Array(32);
      crypto.getRandomValues(key);
      return key;
    }

    function computeX25519PublicKey(privateKey) {
      const basePoint = new Uint8Array(32);
      basePoint[0] = 9;
      return x25519(privateKey, basePoint);
    }

    function x25519SharedSecret(myPrivate, theirPublic) {
      return x25519(myPrivate, theirPublic);
    }

    // ========================================
    // App State & Utilities
    // ========================================
    let myPrivateKey = null;
    let myPublicKey = null;
    let symKey = null;

    const tv = (id) => document.getElementById(id);
    const toast = tv("copyToast");

    function showToast(msg = "Copiado", ms = 1500) {
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toast._t);
      toast._t = setTimeout(() => toast.classList.remove("show"), ms);
    }

    function b64urlEncode(u8) {
      const s = btoa(String.fromCharCode(...u8));
      return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }

    function b64urlDecode(s) {
      s = s.replace(/-/g, "+").replace(/_/g, "/");
      while (s.length % 4) s += "=";
      const bin = atob(s);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    function uint16be(n) {
      return new Uint8Array([(n >> 8) & 0xff, n & 0xff]);
    }

    function readUint16be(u8, off) {
      return (u8[off] << 8) | u8[off + 1];
    }

    async function deriveSymmetricKeyFromShared(sharedSecret) {
      const salt = new Uint8Array();
      const info = new TextEncoder().encode("ecdh:aesgcm");
      const hk = await crypto.subtle.importKey(
        "raw",
        sharedSecret,
        "HKDF",
        false,
        ["deriveKey"]
      );
      const aesKey = await crypto.subtle.deriveKey(
        { name: "HKDF", hash: "SHA-256", salt, info },
        hk,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
      try {
        new Uint8Array(sharedSecret).fill(0);
      } catch (e) {}
      return aesKey;
    }

    async function generateEphemeral() {
      tv("status").textContent = "Generando claves X25519...";
      tv("statusDot").classList.remove("active");

      myPrivateKey = generateX25519PrivateKey();
      myPublicKey = computeX25519PublicKey(myPrivateKey);

      const token = "pub1x" + b64urlEncode(myPublicKey);
      tv("myToken").textContent = token;
      tv("myToken").classList.remove("empty");
      tv("status").textContent = "Token listo";

      tv("peerState").textContent = "";
      showOps(false);
    }

    function regenerateKey() {
      symKey = null;
      tv("peerToken").value = "";
      generateEphemeral();
      showToast("Nuevo token generado");
    }

    function parsePeerToken(token) {
      if (!token || !token.startsWith("pub1x"))
        throw new Error("Token inv√°lido (debe empezar con pub1x)");
      const rawB64 = token.slice(5);
      const raw = b64urlDecode(rawB64);
      if (raw.length !== 32)
        throw new Error("Longitud de clave X25519 inv√°lida");
      return raw;
    }

    async function connectPeer() {
      try {
        const token = tv("peerToken").value.trim();
        if (!token) {
          tv("peerState").textContent = "‚ùå Campo vac√≠o";
          tv("peerState").style.color = "#e94560";
          return;
        }

        let peerPublic;
        try {
          peerPublic = parsePeerToken(token);
        } catch (e) {
          tv("peerState").textContent = "‚ùå Token inv√°lido";
          tv("peerState").style.color = "#e94560";
          return;
        }

        const sharedSecret = x25519SharedSecret(myPrivateKey, peerPublic);
        symKey = await deriveSymmetricKeyFromShared(sharedSecret.buffer);

        tv("peerState").textContent = "‚úÖ ¬°Conectado! Clave compartida establecida";
        tv("peerState").style.color = "#2ecc71";
        tv("status").textContent = "Conectado - Clave sim√©trica derivada";
        tv("statusDot").classList.add("active");
        showOps(true);
        showToast("¬°Conexi√≥n establecida!");
      } catch (e) {
        console.error("Error al conectar:", e);
        tv("peerState").textContent = "‚ùå Error: " + (e.message || String(e));
        tv("peerState").style.color = "#e94560";
      }
    }

    function showOps(on) {
      tv("ops").style.display = on ? "block" : "none";
    }

    function clearText() {
      tv("ptIn").value = "";
      tv("ctOut").textContent = "El mensaje cifrado aparecer√° aqu√≠...";
      tv("ctOut").classList.add("empty");
    }

    function clearCTin() {
      tv("ctIn").value = "";
      tv("ptOut").textContent = "El mensaje descifrado aparecer√° aqu√≠...";
      tv("ptOut").classList.add("empty");
    }

    async function encryptText() {
      if (!symKey) {
        showToast("‚ùå No hay clave. Conecta primero con tu amigo", 2000);
        return;
      }
      const pt = new TextEncoder().encode(tv("ptIn").value);
      if (pt.length === 0) {
        showToast("‚ùå Escribe un mensaje primero", 2000);
        return;
      }
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ct = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        symKey,
        pt
      );
      const payload = new Uint8Array(iv.length + ct.byteLength);
      payload.set(iv, 0);
      payload.set(new Uint8Array(ct), iv.length);
      const txt = b64urlEncode(payload);
      tv("ctOut").textContent = txt;
      tv("ctOut").classList.remove("empty");
      showToast("‚úÖ Mensaje cifrado. Haz clic para copiar");
      try {
        pt.fill(0);
      } catch (e) {}
    }

    async function decryptText() {
      if (!symKey) {
        showToast("‚ùå No hay clave. Conecta primero", 2000);
        return;
      }
      const s = tv("ctIn").value.trim();
      if (!s) {
        showToast("‚ùå Pega un mensaje cifrado primero", 2000);
        return;
      }
      try {
        const payload = b64urlDecode(s);
        if (payload.length < 12 + 16) {
          tv("ptOut").textContent = "‚ùå Mensaje muy corto o corrupto";
          tv("ptOut").classList.remove("empty");
          return;
        }
        const iv = payload.slice(0, 12);
        const ct = payload.slice(12);
        const ptbuf = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv },
          symKey,
          ct
        );
        const pt = new TextDecoder().decode(ptbuf);
        tv("ptOut").textContent = pt;
        tv("ptOut").classList.remove("empty");
        showToast("‚úÖ Mensaje descifrado");
        try {
          new Uint8Array(ptbuf).fill(0);
        } catch (e) {}
      } catch (e) {
        console.error(e);
        tv("ptOut").textContent = "‚ùå Error al descifrar. ¬øToken correcto?";
        tv("ptOut").classList.remove("empty");
        showToast("‚ùå Descifrado fall√≥", 2000);
      }
    }

    async function encryptFile() {
      if (!symKey) {
        showToast("‚ùå No hay clave. Conecta primero", 2000);
        return;
      }
      const fi = tv("fileEnc").files[0];
      if (!fi) {
        showToast("‚ùå Selecciona un archivo primero", 2000);
        return;
      }
      const arr = new Uint8Array(await fi.arrayBuffer());
      const fname = new TextEncoder().encode(fi.name);
      if (fname.length > 0xffff) {
        showToast("‚ùå Nombre de archivo muy largo", 2000);
        return;
      }
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ct = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv, additionalData: fname },
        symKey,
        arr
      );
      const header = new Uint8Array(
        2 + fname.length + iv.length + ct.byteLength
      );
      header.set(uint16be(fname.length), 0);
      header.set(fname, 2);
      header.set(iv, 2 + fname.length);
      header.set(new Uint8Array(ct), 2 + fname.length + iv.length);
      const blob = new Blob([header], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fi.name + ".enc";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast("‚úÖ Archivo cifrado y descargado");
      try {
        arr.fill(0);
      } catch (e) {}
    }

    async function decryptFile() {
      if (!symKey) {
        showToast("‚ùå No hay clave. Conecta primero", 2000);
        return;
      }
      const fi = tv("fileDec").files[0];
      if (!fi) {
        showToast("‚ùå Selecciona un archivo .enc primero", 2000);
        return;
      }
      const buf = new Uint8Array(await fi.arrayBuffer());
      if (buf.length < 2 + 12 + 16) {
        showToast("‚ùå Archivo muy peque√±o o corrupto", 2000);
        return;
      }
      const namelen = readUint16be(buf, 0);
      if (buf.length < 2 + namelen + 12 + 16) {
        showToast("‚ùå Archivo truncado", 2000);
        return;
      }
      const fname = buf.slice(2, 2 + namelen);
      const ivOff = 2 + namelen;
      const iv = buf.slice(ivOff, ivOff + 12);
      const ct = buf.slice(ivOff + 12);
      try {
        const ptbuf = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv, additionalData: fname },
          symKey,
          ct
        );
        const outName = new TextDecoder().decode(fname);
        const blob = new Blob([ptbuf], { type: "application/octet-stream" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = outName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showToast("‚úÖ Archivo descifrado y descargado");
        try {
          new Uint8Array(ptbuf).fill(0);
        } catch (e) {}
      } catch (e) {
        console.error(e);
        showToast("‚ùå Descifrado fall√≥. ¬øToken correcto?", 2500);
      }
    }

    function downloadText(filename, text) {
      const b = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(b);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        showToast("üìã Copiado");
      } catch (e) {
        showToast("‚ùå Error al copiar");
      }
    }

    function copyMyToken() {
      const t = tv("myToken").textContent.trim();
      if (t && !t.includes("Generando")) copyText(t);
    }

    function downloadPubToken() {
      const t = tv("myToken").textContent.trim();
      if (t && !t.includes("Generando")) {
        downloadText("mi_token_publico.txt", t);
        showToast("üíæ Token descargado");
      }
    }

    function copyOutput(elemId) {
      const elem = tv(elemId);
      if (!elem.classList.contains("empty")) {
        const t = elem.textContent.trim();
        if (t) copyText(t);
      }
    }

    // Inicializar
    generateEphemeral().catch((e) => {
      console.error(e);
      tv("status").textContent = "‚ùå Error al inicializar";
    });

    // Limpiar al cerrar
    window.addEventListener("unload", () => {
      try {
        if (myPrivateKey) myPrivateKey.fill(0);
        if (myPublicKey) myPublicKey.fill(0);
        myPrivateKey = null;
        myPublicKey = null;
        symKey = null;
      } catch (e) {}
    });
  </script>
</body>
</html>
