<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>QR Maker</title>
<style>
:root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;--muted:#6b7280;--accent:#06f}
html,body{height:100%;margin:0;background:#071428;color:#e6eef6}
.container{max-width:720px;margin:12px auto;padding:18px;border-radius:12px;background:transparent}
.header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:14px}
.title{font-size:18px;font-weight:600}
.controls{display:flex;gap:8px;align-items:center}
.toggle{display:inline-flex;border-radius:10px;overflow:hidden;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
.toggle button{appearance:none;border:0;padding:8px 12px;background:transparent;color:var(--muted);font-weight:600;cursor:pointer;min-width:80px}
.toggle button[aria-pressed="true"]{background:var(--accent);color:#001;box-shadow:0 4px 10px rgba(6,120,255,0.12)}
.row{display:flex;gap:10px;flex-wrap:wrap}
.input-wrap{flex:1;min-width:160px}
input[type="text"]{width:100%;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:15px;box-sizing:border-box}
.actions{display:flex;gap:8px;align-items:center}
.button{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--accent),#0b7cff);color:#001;font-weight:700;cursor:pointer;min-width:44px;box-shadow:0 6px 18px rgba(3,10,40,0.5)}
.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:700}
.canvas-wrap{display:flex;justify-content:center;margin-top:16px}
canvas{width:min(84vw,320px);height:auto;border-radius:12px;background:#fff;padding:8px}
.note{margin-top:10px;color:var(--muted);font-size:13px}
.footer{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}

/* mobile-only card look: keep compact card styling on small screens, remove card visuals on desktop */
@media (max-width:420px){
  .container{margin:12px;padding:12px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  .title{font-size:16px}
  .toggle button{min-width:68px;padding:8px 10px}
}

/* desktop: no card background, no shadow (card CSS removed for desktop) */
@media (min-width:421px){
  .container{background:transparent;box-shadow:none;padding:18px}
}
</style>
</head>
<body>
<main class="container" role="main">
  <div class="header">
    <div class="title">QR Maker</div>
    <div class="controls">
      <div class="toggle" role="tablist" aria-label="mode">
        <button id="mode-text" aria-pressed="true" type="button">Text</button>
        <button id="mode-url" aria-pressed="false" type="button">URL</button>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="input-wrap">
      <input id="payload" type="text" inputmode="text" autocomplete="off" placeholder="Enter text">
    </div>
    <div class="actions">
      <button id="generate" class="button" type="button">Generate</button>
      <button id="download" class="button secondary" type="button">Download PNG</button>
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="qr" width="512" height="512" aria-label="QR preview"></canvas>
  </div>

  <div class="note">Normal text or URL mode. Output is a clean PNG without appended metadata.</div>
</main>

<script>
const elModeText = document.getElementById('mode-text');
const elModeUrl = document.getElementById('mode-url');
const input = document.getElementById('payload');
const btnGen = document.getElementById('generate');
const btnDownload = document.getElementById('download');
const canvas = document.getElementById('qr');
const ctx = canvas.getContext('2d');

function setMode(mode){
  elModeText.setAttribute('aria-pressed', mode === 'text' ? 'true' : 'false');
  elModeUrl.setAttribute('aria-pressed', mode === 'url' ? 'true' : 'false');
  input.placeholder = mode === 'url' ? 'https://example.com' : 'Enter text';
  input.inputMode = mode === 'url' ? 'url' : 'text';
  input.value = input.value.trim();
}
elModeText.addEventListener('click', () => setMode('text'));
elModeUrl.addEventListener('click', () => setMode('url'));

function drawBlank(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#dce8f8';
  ctx.font = 'bold 96px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('QR', canvas.width/2, canvas.height/2);
}
drawBlank();

function buildGoogleQRUrl(data, size){
  return 'https://chart.googleapis.com/chart?cht=qr&chs=' + size + 'x' + size + '&chl=' + encodeURIComponent(data) + '&choe=UTF-8';
}

/* Attempt to fetch image as blob and draw via createImageBitmap when possible.
   Fallback to objectURL->Image if needed. Final fallback tries direct Image(src).
*/
async function fetchAndDrawQR(data, size){
  const url = buildGoogleQRUrl(data, size);
  // prefer fetch+createImageBitmap (avoids canvas cross-origin taint and keeps download working)
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('fetch-error');
    const blob = await resp.blob();
    if (window.createImageBitmap) {
      const bitmap = await createImageBitmap(blob);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
      return;
    } else {
      // fallback for environments without createImageBitmap
      const objUrl = URL.createObjectURL(blob);
      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          URL.revokeObjectURL(objUrl);
          resolve();
        };
        img.onerror = () => { URL.revokeObjectURL(objUrl); reject(new Error('image-load')); };
        img.src = objUrl;
      });
      return;
    }
  } catch (e) {
    // final fallback: try direct Image load (may taint canvas in some browsers)
    try {
      await new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => {
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve();
        };
        img.onerror = () => reject(new Error('final-image-fail'));
        img.src = url;
      });
      return;
    } catch(err){
      throw err;
    }
  }
}

async function generate(){
  const val = input.value.trim();
  if (!val) { drawBlank(); return; }
  const mode = elModeUrl.getAttribute('aria-pressed') === 'true' ? 'url' : 'text';
  const out = mode === 'url' ? (val.match(/^https?:\/\//i) ? val : 'https://' + val) : val;
  try {
    await fetchAndDrawQR(out, 512);
  } catch (err) {
    drawBlank();
    console.error(err);
  }
}

btnGen.addEventListener('click', () => { generate(); });

btnDownload.addEventListener('click', async () => {
  await generate();
  // use toBlob so no metadata and proper PNG
  canvas.toBlob(function(blob){
    if(!blob) return;
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = 'qr.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
  }, 'image/png');
});

input.addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); generate(); }
});
</script>
</body>
</html>